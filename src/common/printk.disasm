
/home/blessed/Programowanie/blessOS/ex/src/common/printk.o:     file format elf32-i386


Disassembly of section .text:

00000000 <parse_hex>:

#include <common/types.h>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	53                   	push   %ebx
   4:	83 ec 10             	sub    $0x10,%esp
    int i = 7;
   7:	c7 45 f8 07 00 00 00 	movl   $0x7,-0x8(%ebp)
    while (i-- >= 0)
   e:	eb 24                	jmp    34 <parse_hex+0x34>
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
  10:	8b 45 f8             	mov    -0x8(%ebp),%eax
  13:	c1 e0 02             	shl    $0x2,%eax
  16:	8b 55 0c             	mov    0xc(%ebp),%edx
  19:	89 d3                	mov    %edx,%ebx
  1b:	89 c1                	mov    %eax,%ecx
  1d:	d3 fb                	sar    %cl,%ebx
  1f:	89 d8                	mov    %ebx,%eax
  21:	83 e0 0f             	and    $0xf,%eax
  24:	0f b6 90 00 00 00 00 	movzbl 0x0(%eax),%edx
			27: R_386_32	.rodata
  2b:	8b 45 08             	mov    0x8(%ebp),%eax
  2e:	88 10                	mov    %dl,(%eax)
  30:	83 45 08 01          	addl   $0x1,0x8(%ebp)
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
    int i = 7;
    while (i-- >= 0)
  34:	8b 45 f8             	mov    -0x8(%ebp),%eax
  37:	f7 d0                	not    %eax
  39:	c1 e8 1f             	shr    $0x1f,%eax
  3c:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  40:	84 c0                	test   %al,%al
  42:	75 cc                	jne    10 <parse_hex+0x10>
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
    }
}
  44:	83 c4 10             	add    $0x10,%esp
  47:	5b                   	pop    %ebx
  48:	5d                   	pop    %ebp
  49:	c3                   	ret    

0000004a <parse_num>:

static void parse_num(char *buf, int num, int base)
{
  4a:	55                   	push   %ebp
  4b:	89 e5                	mov    %esp,%ebp
  4d:	83 ec 28             	sub    $0x28,%esp
    u32int n = num / base;
  50:	8b 45 0c             	mov    0xc(%ebp),%eax
  53:	89 c2                	mov    %eax,%edx
  55:	c1 fa 1f             	sar    $0x1f,%edx
  58:	f7 7d 10             	idivl  0x10(%ebp)
  5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int r = num % base;
  5e:	8b 45 0c             	mov    0xc(%ebp),%eax
  61:	89 c2                	mov    %eax,%edx
  63:	c1 fa 1f             	sar    $0x1f,%edx
  66:	f7 7d 10             	idivl  0x10(%ebp)
  69:	89 55 f0             	mov    %edx,-0x10(%ebp)
    if (r < 0)
  6c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  70:	79 0a                	jns    7c <parse_num+0x32>
    {
        r += base;
  72:	8b 45 10             	mov    0x10(%ebp),%eax
  75:	01 45 f0             	add    %eax,-0x10(%ebp)
        --n;
  78:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    }

    if (num >= base)
  7c:	8b 45 0c             	mov    0xc(%ebp),%eax
  7f:	3b 45 10             	cmp    0x10(%ebp),%eax
  82:	7c 19                	jl     9d <parse_num+0x53>
        parse_num(buf, n, base);
  84:	8b 45 f4             	mov    -0xc(%ebp),%eax
  87:	8b 55 10             	mov    0x10(%ebp),%edx
  8a:	89 54 24 08          	mov    %edx,0x8(%esp)
  8e:	89 44 24 04          	mov    %eax,0x4(%esp)
  92:	8b 45 08             	mov    0x8(%ebp),%eax
  95:	89 04 24             	mov    %eax,(%esp)
  98:	e8 ad ff ff ff       	call   4a <parse_num>

    *buf++ = "0123456789"[r];
  9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  a0:	05 11 00 00 00       	add    $0x11,%eax
			a1: R_386_32	.rodata
  a5:	0f b6 10             	movzbl (%eax),%edx
  a8:	8b 45 08             	mov    0x8(%ebp),%eax
  ab:	88 10                	mov    %dl,(%eax)
  ad:	83 45 08 01          	addl   $0x1,0x8(%ebp)
}
  b1:	c9                   	leave  
  b2:	c3                   	ret    

000000b3 <printk_get_level>:

int printk_get_level(const char *buffer)
{
  b3:	55                   	push   %ebp
  b4:	89 e5                	mov    %esp,%ebp
    if (buffer[0] == KERN_SOH_ASCII && buffer[1])
  b6:	8b 45 08             	mov    0x8(%ebp),%eax
  b9:	0f b6 00             	movzbl (%eax),%eax
  bc:	3c 01                	cmp    $0x1,%al
  be:	75 36                	jne    f6 <printk_get_level+0x43>
  c0:	8b 45 08             	mov    0x8(%ebp),%eax
  c3:	83 c0 01             	add    $0x1,%eax
  c6:	0f b6 00             	movzbl (%eax),%eax
  c9:	84 c0                	test   %al,%al
  cb:	74 29                	je     f6 <printk_get_level+0x43>
    {
        switch (buffer[1])
  cd:	8b 45 08             	mov    0x8(%ebp),%eax
  d0:	83 c0 01             	add    $0x1,%eax
  d3:	0f b6 00             	movzbl (%eax),%eax
  d6:	0f be c0             	movsbl %al,%eax
  d9:	83 f8 30             	cmp    $0x30,%eax
  dc:	7c 18                	jl     f6 <printk_get_level+0x43>
  de:	83 f8 37             	cmp    $0x37,%eax
  e1:	7e 05                	jle    e8 <printk_get_level+0x35>
  e3:	83 f8 64             	cmp    $0x64,%eax
  e6:	75 0e                	jne    f6 <printk_get_level+0x43>
        case '4':
        case '5':
        case '6':
        case '7':
        case 'd':
            return buffer[1];
  e8:	8b 45 08             	mov    0x8(%ebp),%eax
  eb:	83 c0 01             	add    $0x1,%eax
  ee:	0f b6 00             	movzbl (%eax),%eax
  f1:	0f be c0             	movsbl %al,%eax
  f4:	eb 05                	jmp    fb <printk_get_level+0x48>
        }
    }

    return 0;
  f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  fb:	5d                   	pop    %ebp
  fc:	c3                   	ret    

000000fd <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
  fd:	55                   	push   %ebp
  fe:	89 e5                	mov    %esp,%ebp
 100:	83 ec 28             	sub    $0x28,%esp
    int i;
    int index;
    char *s;

    index = 0;
 103:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    for (i = 0; fmt[i] != '\0'; ++i)
 10a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 111:	e9 e9 01 00 00       	jmp    2ff <vsprintf+0x202>
    {
        if ((fmt[i] != '%') && (fmt[i] != '\\'))
 116:	8b 55 f4             	mov    -0xc(%ebp),%edx
 119:	8b 45 0c             	mov    0xc(%ebp),%eax
 11c:	01 d0                	add    %edx,%eax
 11e:	0f b6 00             	movzbl (%eax),%eax
 121:	3c 25                	cmp    $0x25,%al
 123:	74 2d                	je     152 <vsprintf+0x55>
 125:	8b 55 f4             	mov    -0xc(%ebp),%edx
 128:	8b 45 0c             	mov    0xc(%ebp),%eax
 12b:	01 d0                	add    %edx,%eax
 12d:	0f b6 00             	movzbl (%eax),%eax
 130:	3c 5c                	cmp    $0x5c,%al
 132:	74 1e                	je     152 <vsprintf+0x55>
        {
            buf[index++] = fmt[i];
 134:	8b 55 f0             	mov    -0x10(%ebp),%edx
 137:	8b 45 08             	mov    0x8(%ebp),%eax
 13a:	01 c2                	add    %eax,%edx
 13c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 13f:	8b 45 0c             	mov    0xc(%ebp),%eax
 142:	01 c8                	add    %ecx,%eax
 144:	0f b6 00             	movzbl (%eax),%eax
 147:	88 02                	mov    %al,(%edx)
 149:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            continue;
 14d:	e9 a9 01 00 00       	jmp    2fb <vsprintf+0x1fe>
        }
        else if (fmt[i] == '%')
 152:	8b 55 f4             	mov    -0xc(%ebp),%edx
 155:	8b 45 0c             	mov    0xc(%ebp),%eax
 158:	01 d0                	add    %edx,%eax
 15a:	0f b6 00             	movzbl (%eax),%eax
 15d:	3c 25                	cmp    $0x25,%al
 15f:	0f 85 0e 01 00 00    	jne    273 <vsprintf+0x176>
        {
            switch(fmt[++i])
 165:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 169:	8b 55 f4             	mov    -0xc(%ebp),%edx
 16c:	8b 45 0c             	mov    0xc(%ebp),%eax
 16f:	01 d0                	add    %edx,%eax
 171:	0f b6 00             	movzbl (%eax),%eax
 174:	0f be c0             	movsbl %al,%eax
 177:	83 f8 70             	cmp    $0x70,%eax
 17a:	0f 84 81 00 00 00    	je     201 <vsprintf+0x104>
 180:	83 f8 70             	cmp    $0x70,%eax
 183:	7f 1c                	jg     1a1 <vsprintf+0xa4>
 185:	83 f8 63             	cmp    $0x63,%eax
 188:	74 5c                	je     1e6 <vsprintf+0xe9>
 18a:	83 f8 64             	cmp    $0x64,%eax
 18d:	0f 84 8b 00 00 00    	je     21e <vsprintf+0x121>
 193:	83 f8 25             	cmp    $0x25,%eax
 196:	0f 84 a7 00 00 00    	je     243 <vsprintf+0x146>
 19c:	e9 b3 00 00 00       	jmp    254 <vsprintf+0x157>
 1a1:	83 f8 73             	cmp    $0x73,%eax
 1a4:	74 0a                	je     1b0 <vsprintf+0xb3>
 1a6:	83 f8 78             	cmp    $0x78,%eax
 1a9:	74 56                	je     201 <vsprintf+0x104>
 1ab:	e9 a4 00 00 00       	jmp    254 <vsprintf+0x157>
            {
            case 's':
                s = (char *)va_arg(args, char *);
 1b0:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 1b4:	8b 45 10             	mov    0x10(%ebp),%eax
 1b7:	8b 40 fc             	mov    -0x4(%eax),%eax
 1ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
                while (*s)
 1bd:	eb 18                	jmp    1d7 <vsprintf+0xda>
                {
                    buf[index++] = *s++;
 1bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
 1c2:	8b 45 08             	mov    0x8(%ebp),%eax
 1c5:	01 c2                	add    %eax,%edx
 1c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 1ca:	0f b6 00             	movzbl (%eax),%eax
 1cd:	88 02                	mov    %al,(%edx)
 1cf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 1d3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        {
            switch(fmt[++i])
            {
            case 's':
                s = (char *)va_arg(args, char *);
                while (*s)
 1d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 1da:	0f b6 00             	movzbl (%eax),%eax
 1dd:	84 c0                	test   %al,%al
 1df:	75 de                	jne    1bf <vsprintf+0xc2>
                {
                    buf[index++] = *s++;
                }
                break;
 1e1:	e9 88 00 00 00       	jmp    26e <vsprintf+0x171>

            case 'c':
                buf[index++] = (char)va_arg(fmt, char);
 1e6:	8b 55 f0             	mov    -0x10(%ebp),%edx
 1e9:	8b 45 08             	mov    0x8(%ebp),%eax
 1ec:	01 c2                	add    %eax,%edx
 1ee:	83 45 0c 04          	addl   $0x4,0xc(%ebp)
 1f2:	8b 45 0c             	mov    0xc(%ebp),%eax
 1f5:	0f b6 40 fc          	movzbl -0x4(%eax),%eax
 1f9:	88 02                	mov    %al,(%edx)
 1fb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
 1ff:	eb 6d                	jmp    26e <vsprintf+0x171>

            case 'p':
            case 'x':
                parse_hex(buf, (u32int)va_arg(args, u32int));
 201:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 205:	8b 45 10             	mov    0x10(%ebp),%eax
 208:	83 e8 04             	sub    $0x4,%eax
 20b:	8b 00                	mov    (%eax),%eax
 20d:	89 44 24 04          	mov    %eax,0x4(%esp)
 211:	8b 45 08             	mov    0x8(%ebp),%eax
 214:	89 04 24             	mov    %eax,(%esp)
 217:	e8 e4 fd ff ff       	call   0 <parse_hex>
                break;
 21c:	eb 50                	jmp    26e <vsprintf+0x171>

            case 'd':
                parse_num(buf, (u32int)va_arg(args, u32int), 10);
 21e:	83 45 10 04          	addl   $0x4,0x10(%ebp)
 222:	8b 45 10             	mov    0x10(%ebp),%eax
 225:	83 e8 04             	sub    $0x4,%eax
 228:	8b 00                	mov    (%eax),%eax
 22a:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 231:	00 
 232:	89 44 24 04          	mov    %eax,0x4(%esp)
 236:	8b 45 08             	mov    0x8(%ebp),%eax
 239:	89 04 24             	mov    %eax,(%esp)
 23c:	e8 09 fe ff ff       	call   4a <parse_num>
                break;
 241:	eb 2b                	jmp    26e <vsprintf+0x171>

            case '%':
                buf[index++] = '%';
 243:	8b 55 f0             	mov    -0x10(%ebp),%edx
 246:	8b 45 08             	mov    0x8(%ebp),%eax
 249:	01 d0                	add    %edx,%eax
 24b:	c6 00 25             	movb   $0x25,(%eax)
 24e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
 252:	eb 1a                	jmp    26e <vsprintf+0x171>

            default:
                buf[index++] = fmt[i];
 254:	8b 55 f0             	mov    -0x10(%ebp),%edx
 257:	8b 45 08             	mov    0x8(%ebp),%eax
 25a:	01 c2                	add    %eax,%edx
 25c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 25f:	8b 45 0c             	mov    0xc(%ebp),%eax
 262:	01 c8                	add    %ecx,%eax
 264:	0f b6 00             	movzbl (%eax),%eax
 267:	88 02                	mov    %al,(%edx)
 269:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
 26d:	90                   	nop
            }

            continue;
 26e:	e9 88 00 00 00       	jmp    2fb <vsprintf+0x1fe>
        }

        switch(fmt[++i])
 273:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 277:	8b 55 f4             	mov    -0xc(%ebp),%edx
 27a:	8b 45 0c             	mov    0xc(%ebp),%eax
 27d:	01 d0                	add    %edx,%eax
 27f:	0f b6 00             	movzbl (%eax),%eax
 282:	0f be c0             	movsbl %al,%eax
 285:	83 e8 5c             	sub    $0x5c,%eax
 288:	83 f8 18             	cmp    $0x18,%eax
 28b:	77 6e                	ja     2fb <vsprintf+0x1fe>
 28d:	8b 04 85 1c 00 00 00 	mov    0x1c(,%eax,4),%eax
			290: R_386_32	.rodata
 294:	ff e0                	jmp    *%eax
        {
        case 'a':
            buf[index++] = '\a'; break;
 296:	8b 55 f0             	mov    -0x10(%ebp),%edx
 299:	8b 45 08             	mov    0x8(%ebp),%eax
 29c:	01 d0                	add    %edx,%eax
 29e:	c6 00 07             	movb   $0x7,(%eax)
 2a1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 2a5:	eb 54                	jmp    2fb <vsprintf+0x1fe>
        case 'b':
            buf[index++] = '\b'; break;
 2a7:	8b 55 f0             	mov    -0x10(%ebp),%edx
 2aa:	8b 45 08             	mov    0x8(%ebp),%eax
 2ad:	01 d0                	add    %edx,%eax
 2af:	c6 00 08             	movb   $0x8,(%eax)
 2b2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 2b6:	eb 43                	jmp    2fb <vsprintf+0x1fe>
        case 't':
            buf[index++] = '\t'; break;
 2b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
 2bb:	8b 45 08             	mov    0x8(%ebp),%eax
 2be:	01 d0                	add    %edx,%eax
 2c0:	c6 00 09             	movb   $0x9,(%eax)
 2c3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 2c7:	eb 32                	jmp    2fb <vsprintf+0x1fe>
        case 'n':
            buf[index++] = '\n'; break;
 2c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
 2cc:	8b 45 08             	mov    0x8(%ebp),%eax
 2cf:	01 d0                	add    %edx,%eax
 2d1:	c6 00 0a             	movb   $0xa,(%eax)
 2d4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 2d8:	eb 21                	jmp    2fb <vsprintf+0x1fe>
        case 'r':
            buf[index++] = '\r'; break;
 2da:	8b 55 f0             	mov    -0x10(%ebp),%edx
 2dd:	8b 45 08             	mov    0x8(%ebp),%eax
 2e0:	01 d0                	add    %edx,%eax
 2e2:	c6 00 0d             	movb   $0xd,(%eax)
 2e5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 2e9:	eb 10                	jmp    2fb <vsprintf+0x1fe>
        case '\\':
            buf[index++] = '\\'; break;
 2eb:	8b 55 f0             	mov    -0x10(%ebp),%edx
 2ee:	8b 45 08             	mov    0x8(%ebp),%eax
 2f1:	01 d0                	add    %edx,%eax
 2f3:	c6 00 5c             	movb   $0x5c,(%eax)
 2f6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 2fa:	90                   	nop
    int index;
    char *s;

    index = 0;

    for (i = 0; fmt[i] != '\0'; ++i)
 2fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 2ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
 302:	8b 45 0c             	mov    0xc(%ebp),%eax
 305:	01 d0                	add    %edx,%eax
 307:	0f b6 00             	movzbl (%eax),%eax
 30a:	84 c0                	test   %al,%al
 30c:	0f 85 04 fe ff ff    	jne    116 <vsprintf+0x19>
        case '\\':
            buf[index++] = '\\'; break;
        }
    }

    buf[index] = '\0';
 312:	8b 55 f0             	mov    -0x10(%ebp),%edx
 315:	8b 45 08             	mov    0x8(%ebp),%eax
 318:	01 d0                	add    %edx,%eax
 31a:	c6 00 00             	movb   $0x0,(%eax)
    va_end(args);
 31d:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)

    return index;
 324:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 327:	c9                   	leave  
 328:	c3                   	ret    

00000329 <printk>:

int printk(const char *fmt, ...)
{
 329:	55                   	push   %ebp
 32a:	89 e5                	mov    %esp,%ebp
 32c:	81 ec 28 04 00 00    	sub    $0x428,%esp
    int len;
    va_list args;
    char buf[1024];

    va_start(args, fmt);
 332:	8d 45 0c             	lea    0xc(%ebp),%eax
 335:	89 45 f4             	mov    %eax,-0xc(%ebp)
    len = vsprintf(buf, fmt, args);
 338:	8b 45 08             	mov    0x8(%ebp),%eax
 33b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 33e:	89 54 24 08          	mov    %edx,0x8(%esp)
 342:	89 44 24 04          	mov    %eax,0x4(%esp)
 346:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
 34c:	89 04 24             	mov    %eax,(%esp)
 34f:	e8 fc ff ff ff       	call   350 <printk+0x27>
			350: R_386_PC32	vsprintf
 354:	89 45 f0             	mov    %eax,-0x10(%ebp)
    va_end(args);
 357:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)



    return len;
 35e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 361:	c9                   	leave  
 362:	c3                   	ret    

Disassembly of section .rodata:

00000000 <.rodata>:
   0:	30 31                	xor    %dh,(%ecx)
   2:	32 33                	xor    (%ebx),%dh
   4:	34 35                	xor    $0x35,%al
   6:	36                   	ss
   7:	37                   	aaa    
   8:	38 39                	cmp    %bh,(%ecx)
   a:	61                   	popa   
   b:	62 63 64             	bound  %esp,0x64(%ebx)
   e:	65                   	gs
   f:	66                   	data16
  10:	00 30                	add    %dh,(%eax)
  12:	31 32                	xor    %esi,(%edx)
  14:	33 34 35 36 37 38 39 	xor    0x39383736(,%esi,1),%esi
  1b:	00 eb                	add    %ch,%bl
			1c: R_386_32	.text
  1d:	02 00                	add    (%eax),%al
  1f:	00 fb                	add    %bh,%bl
			20: R_386_32	.text
  21:	02 00                	add    (%eax),%al
  23:	00 fb                	add    %bh,%bl
			24: R_386_32	.text
  25:	02 00                	add    (%eax),%al
  27:	00 fb                	add    %bh,%bl
			28: R_386_32	.text
  29:	02 00                	add    (%eax),%al
  2b:	00 fb                	add    %bh,%bl
			2c: R_386_32	.text
  2d:	02 00                	add    (%eax),%al
  2f:	00 96 02 00 00 a7    	add    %dl,-0x58fffffe(%esi)
			30: R_386_32	.text
			34: R_386_32	.text
  35:	02 00                	add    (%eax),%al
  37:	00 fb                	add    %bh,%bl
			38: R_386_32	.text
  39:	02 00                	add    (%eax),%al
  3b:	00 fb                	add    %bh,%bl
			3c: R_386_32	.text
  3d:	02 00                	add    (%eax),%al
  3f:	00 fb                	add    %bh,%bl
			40: R_386_32	.text
  41:	02 00                	add    (%eax),%al
  43:	00 fb                	add    %bh,%bl
			44: R_386_32	.text
  45:	02 00                	add    (%eax),%al
  47:	00 fb                	add    %bh,%bl
			48: R_386_32	.text
  49:	02 00                	add    (%eax),%al
  4b:	00 fb                	add    %bh,%bl
			4c: R_386_32	.text
  4d:	02 00                	add    (%eax),%al
  4f:	00 fb                	add    %bh,%bl
			50: R_386_32	.text
  51:	02 00                	add    (%eax),%al
  53:	00 fb                	add    %bh,%bl
			54: R_386_32	.text
  55:	02 00                	add    (%eax),%al
  57:	00 fb                	add    %bh,%bl
			58: R_386_32	.text
  59:	02 00                	add    (%eax),%al
  5b:	00 fb                	add    %bh,%bl
			5c: R_386_32	.text
  5d:	02 00                	add    (%eax),%al
  5f:	00 fb                	add    %bh,%bl
			60: R_386_32	.text
  61:	02 00                	add    (%eax),%al
  63:	00 c9                	add    %cl,%cl
			64: R_386_32	.text
  65:	02 00                	add    (%eax),%al
  67:	00 fb                	add    %bh,%bl
			68: R_386_32	.text
  69:	02 00                	add    (%eax),%al
  6b:	00 fb                	add    %bh,%bl
			6c: R_386_32	.text
  6d:	02 00                	add    (%eax),%al
  6f:	00 fb                	add    %bh,%bl
			70: R_386_32	.text
  71:	02 00                	add    (%eax),%al
  73:	00 da                	add    %bl,%dl
			74: R_386_32	.text
  75:	02 00                	add    (%eax),%al
  77:	00 fb                	add    %bh,%bl
			78: R_386_32	.text
  79:	02 00                	add    (%eax),%al
  7b:	00                   	.byte 0x0
  7c:	b8                   	.byte 0xb8
			7c: R_386_32	.text
  7d:	02 00                	add    (%eax),%al
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:

#include <common/types.h>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
   0:	13 02                	adc    (%edx),%eax
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
   6:	00 00                	add    %al,(%eax)
			6: R_386_32	.debug_abbrev
    int i = 7;
   8:	00 00                	add    %al,(%eax)
   a:	04 01                	add    $0x1,%al
   c:	14 00                	adc    $0x0,%al
			c: R_386_32	.debug_str
    while (i-- >= 0)
   e:	00 00                	add    %al,(%eax)
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
  10:	01 74 00 00          	add    %esi,0x0(%eax,%eax,1)
			11: R_386_32	.debug_str
  14:	00 00                	add    %al,(%eax)
			15: R_386_32	.text
  16:	00 00                	add    %al,(%eax)
  18:	00 63 03             	add    %ah,0x3(%ebx)
			19: R_386_32	.text
  1b:	00 00                	add    %al,(%eax)
  1d:	00 00                	add    %al,(%eax)
			1d: R_386_32	.debug_line
  1f:	00 00                	add    %al,(%eax)
  21:	02 6c 00 00          	add    0x0(%eax,%eax,1),%ch
			22: R_386_32	.debug_str
  25:	00 02                	add    %al,(%edx)
  27:	08 2c 00             	or     %ch,(%eax,%eax,1)
  2a:	00 00                	add    %al,(%eax)
  2c:	03 04 32             	add    (%edx,%esi,1),%eax
  2f:	00 00                	add    %al,(%eax)
  31:	00 04 01             	add    %al,(%ecx,%eax,1)
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
    int i = 7;
    while (i-- >= 0)
  34:	06                   	push   %es
  35:	67 00 00             	add    %al,(%bx,%si)
			35: R_386_32	.debug_str
  38:	00 05 04 05 69 6e    	add    %al,0x6e690504
  3e:	74 00                	je     40 <.debug_info+0x40>
  40:	02 0d 00 00 00 02    	add    0x2000000,%cl
			41: R_386_32	.debug_str
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
    }
}
  46:	14 4b                	adc    $0x4b,%al
  48:	00 00                	add    %al,(%eax)

static void parse_num(char *buf, int num, int base)
{
  4a:	00 04 04             	add    %al,(%esp,%eax,1)
  4d:	07                   	pop    %es
  4e:	00 00                	add    %al,(%eax)
			4e: R_386_32	.debug_str
    u32int n = num / base;
  50:	00 00                	add    %al,(%eax)
  52:	04 02                	add    $0x2,%al
  54:	07                   	pop    %es
  55:	b4 00                	mov    $0x0,%ah
			55: R_386_32	.debug_str
  57:	00 00                	add    %al,(%eax)
  59:	04 01                	add    $0x1,%al
  5b:	08 59 00             	or     %bl,0x0(%ecx)
			5c: R_386_32	.debug_str
    int r = num % base;
  5e:	00 00                	add    %al,(%eax)
  60:	06                   	push   %es
  61:	40                   	inc    %eax
			61: R_386_32	.debug_str
  62:	00 00                	add    %al,(%eax)
  64:	00 01                	add    %al,(%ecx)
  66:	06                   	push   %es
  67:	01 00                	add    %eax,(%eax)
			68: R_386_32	.text
  69:	00 00                	add    %al,(%eax)
  6b:	00 4a 00             	add    %cl,0x0(%edx)
			6c: R_386_32	.text
    if (r < 0)
  6e:	00 00                	add    %al,(%eax)
  70:	00 00                	add    %al,(%eax)
			70: R_386_32	.debug_loc
    {
        r += base;
  72:	00 00                	add    %al,(%eax)
  74:	01 a2 00 00 00 07    	add    %esp,0x7000000(%edx)
        --n;
  7a:	62 75 66             	bound  %esi,0x66(%ebp)
    }

    if (num >= base)
  7d:	00 01                	add    %al,(%ecx)
  7f:	06                   	push   %es
  80:	2c 00                	sub    $0x0,%al
  82:	00 00                	add    %al,(%eax)
        parse_num(buf, n, base);
  84:	02 91 00 07 6e 75    	add    0x756e0700(%ecx),%dl
  8a:	6d                   	insl   (%dx),%es:(%edi)
  8b:	00 01                	add    %al,(%ecx)
  8d:	06                   	push   %es
  8e:	39 00                	cmp    %eax,(%eax)
  90:	00 00                	add    %al,(%eax)
  92:	02 91 04 08 69 00    	add    0x690804(%ecx),%dl
  98:	01 08                	add    %ecx,(%eax)
  9a:	39 00                	cmp    %eax,(%eax)
  9c:	00 00                	add    %al,(%eax)

    *buf++ = "0123456789"[r];
  9e:	02 91 70 00 09 31    	add    0x31090070(%ecx),%dl
			a3: R_386_32	.debug_str
  a4:	00 00                	add    %al,(%eax)
  a6:	00 01                	add    %al,(%ecx)
  a8:	0f 01 4a 00          	sidtl  0x0(%edx)
			aa: R_386_32	.text
  ac:	00 00                	add    %al,(%eax)
  ae:	b3 00                	mov    $0x0,%bl
			ae: R_386_32	.text
  b0:	00 00                	add    %al,(%eax)
}
  b2:	38 00                	cmp    %al,(%eax)
			b2: R_386_32	.debug_loc

int printk_get_level(const char *buffer)
{
  b4:	00 00                	add    %al,(%eax)
    if (buffer[0] == KERN_SOH_ASCII && buffer[1])
  b6:	01 fe                	add    %edi,%esi
  b8:	00 00                	add    %al,(%eax)
  ba:	00 07                	add    %al,(%edi)
  bc:	62 75 66             	bound  %esi,0x66(%ebp)
  bf:	00 01                	add    %al,(%ecx)
  c1:	0f 2c 00             	cvttps2pi (%eax),%mm0
  c4:	00 00                	add    %al,(%eax)
  c6:	02 91 00 07 6e 75    	add    0x756e0700(%ecx),%dl
  cc:	6d                   	insl   (%dx),%es:(%edi)
    {
        switch (buffer[1])
  cd:	00 01                	add    %al,(%ecx)
  cf:	0f 39                	(bad)  
  d1:	00 00                	add    %al,(%eax)
  d3:	00 02                	add    %al,(%edx)
  d5:	91                   	xchg   %eax,%ecx
  d6:	04 0a                	add    $0xa,%al
  d8:	3b 00                	cmp    (%eax),%eax
			d8: R_386_32	.debug_str
  da:	00 00                	add    %al,(%eax)
  dc:	01 0f                	add    %ecx,(%edi)
  de:	39 00                	cmp    %eax,(%eax)
  e0:	00 00                	add    %al,(%eax)
  e2:	02 91 08 08 6e 00    	add    0x6e0808(%ecx),%dl
        case '4':
        case '5':
        case '6':
        case '7':
        case 'd':
            return buffer[1];
  e8:	01 11                	add    %edx,(%ecx)
  ea:	40                   	inc    %eax
  eb:	00 00                	add    %al,(%eax)
  ed:	00 02                	add    %al,(%edx)
  ef:	91                   	xchg   %eax,%ecx
  f0:	6c                   	insb   (%dx),%es:(%edi)
  f1:	08 72 00             	or     %dh,0x0(%edx)
  f4:	01 12                	add    %edx,(%edx)
        }
    }

    return 0;
  f6:	39 00                	cmp    %eax,(%eax)
  f8:	00 00                	add    %al,(%eax)
  fa:	02 91 68 00 0b 01    	add    0x10b0068(%ecx),%dl
}

int vsprintf(char *buf, const char *fmt, va_list args)
{
 100:	20 00                	and    %al,(%eax)
			100: R_386_32	.debug_str
 102:	00 00                	add    %al,(%eax)
    int i;
    int index;
    char *s;

    index = 0;
 104:	01 1f                	add    %ebx,(%edi)
 106:	01 39                	add    %edi,(%ecx)
 108:	00 00                	add    %al,(%eax)

    for (i = 0; fmt[i] != '\0'; ++i)
 10a:	00 b3 00 00 00 fd    	add    %dh,-0x3000000(%ebx)
			10b: R_386_32	.text
			10f: R_386_32	.text
 110:	00 00                	add    %al,(%eax)
 112:	00 70 00             	add    %dh,0x0(%eax)
			113: R_386_32	.debug_loc
 115:	00 00                	add    %al,(%eax)
    {
        if ((fmt[i] != '%') && (fmt[i] != '\\'))
 117:	01 2b                	add    %ebp,(%ebx)
 119:	01 00                	add    %eax,(%eax)
 11b:	00 0a                	add    %cl,(%edx)
 11d:	ce                   	into   
			11d: R_386_32	.debug_str
 11e:	00 00                	add    %al,(%eax)
 120:	00 01                	add    %al,(%ecx)
 122:	1f                   	pop    %ds
 123:	2b 01                	sub    (%ecx),%eax
 125:	00 00                	add    %al,(%eax)
 127:	02 91 00 00 03 04    	add    0x4030000(%ecx),%dl
 12d:	31 01                	xor    %eax,(%ecx)
 12f:	00 00                	add    %al,(%eax)
 131:	0c 32                	or     $0x32,%al
 133:	00 00                	add    %al,(%eax)
        {
            buf[index++] = fmt[i];
 135:	00 0d 01 50 00 00    	add    %cl,0x5001
			138: R_386_32	.debug_str
 13b:	00 01                	add    %al,(%ecx)
 13d:	35 01 39 00 00       	xor    $0x3901,%eax
 142:	00 fd                	add    %bh,%ch
			143: R_386_32	.text
 144:	00 00                	add    %al,(%eax)
 146:	00 29                	add    %ch,(%ecx)
			147: R_386_32	.text
 148:	03 00                	add    (%eax),%eax
 14a:	00 a8 00 00 00 01    	add    %ch,0x1000000(%eax)
			14b: R_386_32	.debug_loc
            continue;
 150:	a5                   	movsl  %ds:(%esi),%es:(%edi)
 151:	01 00                	add    %eax,(%eax)
        }
        else if (fmt[i] == '%')
 153:	00 07                	add    %al,(%edi)
 155:	62 75 66             	bound  %esi,0x66(%ebp)
 158:	00 01                	add    %al,(%ecx)
 15a:	35 2c 00 00 00       	xor    $0x2c,%eax
 15f:	02 91 00 07 66 6d    	add    0x6d660700(%ecx),%dl
        {
            switch(fmt[++i])
 165:	74 00                	je     167 <.debug_info+0x167>
 167:	01 35 2b 01 00 00    	add    %esi,0x12b
 16d:	02 91 04 0a af 00    	add    0xaf0a04(%ecx),%dl
			171: R_386_32	.debug_str
 173:	00 00                	add    %al,(%eax)
 175:	01 35 21 00 00 00    	add    %esi,0x21
 17b:	02 91 08 08 69 00    	add    0x690808(%ecx),%dl
 181:	01 37                	add    %esi,(%edi)
 183:	39 00                	cmp    %eax,(%eax)
 185:	00 00                	add    %al,(%eax)
 187:	02 91 6c 0e 4a 00    	add    0x4a0e6c(%ecx),%dl
			18b: R_386_32	.debug_str
 18d:	00 00                	add    %al,(%eax)
 18f:	01 38                	add    %edi,(%eax)
 191:	39 00                	cmp    %eax,(%eax)
 193:	00 00                	add    %al,(%eax)
 195:	02 91 68 08 73 00    	add    0x730868(%ecx),%dl
 19b:	01 39                	add    %edi,(%ecx)
 19d:	2c 00                	sub    $0x0,%al
 19f:	00 00                	add    %al,(%eax)
 1a1:	02 91 64 00 0d 01    	add    0x10d0064(%ecx),%dl
 1a7:	c7 00 00 00 01 80    	movl   $0x80010000,(%eax)
			1a7: R_386_32	.debug_str
 1ad:	01 39                	add    %edi,(%ecx)
 1af:	00 00                	add    %al,(%eax)
            {
            case 's':
                s = (char *)va_arg(args, char *);
 1b1:	00 29                	add    %ch,(%ecx)
			1b2: R_386_32	.text
 1b3:	03 00                	add    (%eax),%eax
 1b5:	00 63 03             	add    %ah,0x3(%ebx)
			1b6: R_386_32	.text
 1b8:	00 00                	add    %al,(%eax)
 1ba:	e0 00                	loopne 1bc <.debug_info+0x1bc>
			1ba: R_386_32	.debug_loc
 1bc:	00 00                	add    %al,(%eax)
                while (*s)
 1be:	01 fe                	add    %edi,%esi
                {
                    buf[index++] = *s++;
 1c0:	01 00                	add    %eax,(%eax)
 1c2:	00 07                	add    %al,(%edi)
 1c4:	66 6d                	insw   (%dx),%es:(%edi)
 1c6:	74 00                	je     1c8 <.debug_info+0x1c8>
 1c8:	01 80 2b 01 00 00    	add    %eax,0x12b(%eax)
 1ce:	02 91 00 0f 08 6c    	add    0x6c080f00(%ecx),%dl
 1d4:	65 6e                	outsb  %gs:(%esi),(%dx)
 1d6:	00 01                	add    %al,(%ecx)
        {
            switch(fmt[++i])
            {
            case 's':
                s = (char *)va_arg(args, char *);
                while (*s)
 1d8:	82                   	(bad)  
 1d9:	39 00                	cmp    %eax,(%eax)
 1db:	00 00                	add    %al,(%eax)
 1dd:	02 91 68 0e af 00    	add    0xaf0e68(%ecx),%dl
			1e1: R_386_32	.debug_str
                {
                    buf[index++] = *s++;
                }
                break;
 1e3:	00 00                	add    %al,(%eax)
 1e5:	01 83 21 00 00 00    	add    %eax,0x21(%ebx)

            case 'c':
                buf[index++] = (char)va_arg(fmt, char);
 1eb:	02 91 6c 08 62 75    	add    0x7562086c(%ecx),%dl
 1f1:	66                   	data16
 1f2:	00 01                	add    %al,(%ecx)
 1f4:	84 fe                	test   %bh,%dh
 1f6:	01 00                	add    %eax,(%eax)
 1f8:	00 03                	add    %al,(%ebx)
 1fa:	91                   	xchg   %eax,%ecx
 1fb:	e8 77 00 10 32       	call   32100277 <printk+0x320fff4e>
                break;
 200:	00 00                	add    %al,(%eax)

            case 'p':
            case 'x':
                parse_hex(buf, (u32int)va_arg(args, u32int));
 202:	00 0f                	add    %cl,(%edi)
 204:	02 00                	add    (%eax),%al
 206:	00 11                	add    %dl,(%ecx)
 208:	0f 02 00             	lar    (%eax),%eax
 20b:	00 ff                	add    %bh,%bh
 20d:	03 00                	add    (%eax),%eax
 20f:	04 04                	add    $0x4,%al
 211:	07                   	pop    %es
 212:	d5 00                	aad    $0x0
			212: R_386_32	.debug_str
 214:	00 00                	add    %al,(%eax)
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:

#include <common/types.h>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
   0:	01 11                	add    %edx,(%ecx)
   2:	01 25 0e 13 0b 03    	add    %esp,0x30b130e
    int i = 7;
   8:	0e                   	push   %cs
   9:	11 01                	adc    %eax,(%ecx)
   b:	12 01                	adc    (%ecx),%al
   d:	10 06                	adc    %al,(%esi)
    while (i-- >= 0)
   f:	00 00                	add    %al,(%eax)
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
  11:	02 16                	add    (%esi),%dl
  13:	00 03                	add    %al,(%ebx)
  15:	0e                   	push   %cs
  16:	3a 0b                	cmp    (%ebx),%cl
  18:	3b 0b                	cmp    (%ebx),%ecx
  1a:	49                   	dec    %ecx
  1b:	13 00                	adc    (%eax),%eax
  1d:	00 03                	add    %al,(%ebx)
  1f:	0f 00 0b             	str    (%ebx)
  22:	0b 49 13             	or     0x13(%ecx),%ecx
  25:	00 00                	add    %al,(%eax)
  27:	04 24                	add    $0x24,%al
  29:	00 0b                	add    %cl,(%ebx)
  2b:	0b 3e                	or     (%esi),%edi
  2d:	0b 03                	or     (%ebx),%eax
  2f:	0e                   	push   %cs
  30:	00 00                	add    %al,(%eax)
  32:	05 24 00 0b 0b       	add    $0xb0b0024,%eax
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
    int i = 7;
    while (i-- >= 0)
  37:	3e 0b 03             	or     %ds:(%ebx),%eax
  3a:	08 00                	or     %al,(%eax)
  3c:	00 06                	add    %al,(%esi)
  3e:	2e 01 03             	add    %eax,%cs:(%ebx)
  41:	0e                   	push   %cs
  42:	3a 0b                	cmp    (%ebx),%cl
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
    }
}
  44:	3b 0b                	cmp    (%ebx),%ecx
  46:	27                   	daa    
  47:	0c 11                	or     $0x11,%al
  49:	01 12                	add    %edx,(%edx)

static void parse_num(char *buf, int num, int base)
{
  4b:	01 40 06             	add    %eax,0x6(%eax)
  4e:	97                   	xchg   %eax,%edi
  4f:	42                   	inc    %edx
    u32int n = num / base;
  50:	0c 01                	or     $0x1,%al
  52:	13 00                	adc    (%eax),%eax
  54:	00 07                	add    %al,(%edi)
  56:	05 00 03 08 3a       	add    $0x3a080300,%eax
  5b:	0b 3b                	or     (%ebx),%edi
  5d:	0b 49 13             	or     0x13(%ecx),%ecx
    int r = num % base;
  60:	02 0a                	add    (%edx),%cl
  62:	00 00                	add    %al,(%eax)
  64:	08 34 00             	or     %dh,(%eax,%eax,1)
  67:	03 08                	add    (%eax),%ecx
  69:	3a 0b                	cmp    (%ebx),%cl
  6b:	3b 0b                	cmp    (%ebx),%ecx
    if (r < 0)
  6d:	49                   	dec    %ecx
  6e:	13 02                	adc    (%edx),%eax
  70:	0a 00                	or     (%eax),%al
    {
        r += base;
  72:	00 09                	add    %cl,(%ecx)
  74:	2e 01 03             	add    %eax,%cs:(%ebx)
  77:	0e                   	push   %cs
        --n;
  78:	3a 0b                	cmp    (%ebx),%cl
  7a:	3b 0b                	cmp    (%ebx),%ecx
    }

    if (num >= base)
  7c:	27                   	daa    
  7d:	0c 11                	or     $0x11,%al
  7f:	01 12                	add    %edx,(%edx)
  81:	01 40 06             	add    %eax,0x6(%eax)
        parse_num(buf, n, base);
  84:	96                   	xchg   %eax,%esi
  85:	42                   	inc    %edx
  86:	0c 01                	or     $0x1,%al
  88:	13 00                	adc    (%eax),%eax
  8a:	00 0a                	add    %cl,(%edx)
  8c:	05 00 03 0e 3a       	add    $0x3a0e0300,%eax
  91:	0b 3b                	or     (%ebx),%edi
  93:	0b 49 13             	or     0x13(%ecx),%ecx
  96:	02 0a                	add    (%edx),%cl
  98:	00 00                	add    %al,(%eax)
  9a:	0b 2e                	or     (%esi),%ebp
  9c:	01 3f                	add    %edi,(%edi)

    *buf++ = "0123456789"[r];
  9e:	0c 03                	or     $0x3,%al
  a0:	0e                   	push   %cs
  a1:	3a 0b                	cmp    (%ebx),%cl
  a3:	3b 0b                	cmp    (%ebx),%ecx
  a5:	27                   	daa    
  a6:	0c 49                	or     $0x49,%al
  a8:	13 11                	adc    (%ecx),%edx
  aa:	01 12                	add    %edx,(%edx)
  ac:	01 40 06             	add    %eax,0x6(%eax)
  af:	97                   	xchg   %eax,%edi
  b0:	42                   	inc    %edx
}
  b1:	0c 01                	or     $0x1,%al

int printk_get_level(const char *buffer)
{
  b3:	13 00                	adc    (%eax),%eax
  b5:	00 0c 26             	add    %cl,(%esi,%eiz,1)
    if (buffer[0] == KERN_SOH_ASCII && buffer[1])
  b8:	00 49 13             	add    %cl,0x13(%ecx)
  bb:	00 00                	add    %al,(%eax)
  bd:	0d 2e 01 3f 0c       	or     $0xc3f012e,%eax
  c2:	03 0e                	add    (%esi),%ecx
  c4:	3a 0b                	cmp    (%ebx),%cl
  c6:	3b 0b                	cmp    (%ebx),%ecx
  c8:	27                   	daa    
  c9:	0c 49                	or     $0x49,%al
  cb:	13 11                	adc    (%ecx),%edx
    {
        switch (buffer[1])
  cd:	01 12                	add    %edx,(%edx)
  cf:	01 40 06             	add    %eax,0x6(%eax)
  d2:	96                   	xchg   %eax,%esi
  d3:	42                   	inc    %edx
  d4:	0c 01                	or     $0x1,%al
  d6:	13 00                	adc    (%eax),%eax
  d8:	00 0e                	add    %cl,(%esi)
  da:	34 00                	xor    $0x0,%al
  dc:	03 0e                	add    (%esi),%ecx
  de:	3a 0b                	cmp    (%ebx),%cl
  e0:	3b 0b                	cmp    (%ebx),%ecx
  e2:	49                   	dec    %ecx
  e3:	13 02                	adc    (%edx),%eax
  e5:	0a 00                	or     (%eax),%al
  e7:	00 0f                	add    %cl,(%edi)
        case '4':
        case '5':
        case '6':
        case '7':
        case 'd':
            return buffer[1];
  e9:	18 00                	sbb    %al,(%eax)
  eb:	00 00                	add    %al,(%eax)
  ed:	10 01                	adc    %al,(%ecx)
  ef:	01 49 13             	add    %ecx,0x13(%ecx)
  f2:	01 13                	add    %edx,(%ebx)
  f4:	00 00                	add    %al,(%eax)
        }
    }

    return 0;
  f6:	11 21                	adc    %esp,(%ecx)
  f8:	00 49 13             	add    %cl,0x13(%ecx)
}
  fb:	2f                   	das    
  fc:	05                   	.byte 0x5

int vsprintf(char *buf, const char *fmt, va_list args)
{
  fd:	00 00                	add    %al,(%eax)
	...

Disassembly of section .debug_loc:

00000000 <.debug_loc>:

#include <common/types.h>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
   0:	00 00                	add    %al,(%eax)
   2:	00 00                	add    %al,(%eax)
   4:	01 00                	add    %eax,(%eax)
   6:	00 00                	add    %al,(%eax)
    int i = 7;
   8:	02 00                	add    (%eax),%al
   a:	74 04                	je     10 <.debug_loc+0x10>
   c:	01 00                	add    %eax,(%eax)
    while (i-- >= 0)
   e:	00 00                	add    %al,(%eax)
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
  10:	03 00                	add    (%eax),%eax
  12:	00 00                	add    %al,(%eax)
  14:	02 00                	add    (%eax),%al
  16:	74 08                	je     20 <.debug_loc+0x20>
  18:	03 00                	add    (%eax),%eax
  1a:	00 00                	add    %al,(%eax)
  1c:	49                   	dec    %ecx
  1d:	00 00                	add    %al,(%eax)
  1f:	00 02                	add    %al,(%edx)
  21:	00 75 08             	add    %dh,0x8(%ebp)
  24:	49                   	dec    %ecx
  25:	00 00                	add    %al,(%eax)
  27:	00 4a 00             	add    %cl,0x0(%edx)
  2a:	00 00                	add    %al,(%eax)
  2c:	02 00                	add    (%eax),%al
  2e:	74 04                	je     34 <.debug_loc+0x34>
	...
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
    int i = 7;
    while (i-- >= 0)
  38:	4a                   	dec    %edx
  39:	00 00                	add    %al,(%eax)
  3b:	00 4b 00             	add    %cl,0x0(%ebx)
  3e:	00 00                	add    %al,(%eax)
  40:	02 00                	add    (%eax),%al
  42:	74 04                	je     48 <.debug_loc+0x48>
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
    }
}
  44:	4b                   	dec    %ebx
  45:	00 00                	add    %al,(%eax)
  47:	00 4d 00             	add    %cl,0x0(%ebp)

static void parse_num(char *buf, int num, int base)
{
  4a:	00 00                	add    %al,(%eax)
  4c:	02 00                	add    (%eax),%al
  4e:	74 08                	je     58 <.debug_loc+0x58>
    u32int n = num / base;
  50:	4d                   	dec    %ebp
  51:	00 00                	add    %al,(%eax)
  53:	00 b2 00 00 00 02    	add    %dh,0x2000000(%edx)
  59:	00 75 08             	add    %dh,0x8(%ebp)
  5c:	b2 00                	mov    $0x0,%dl
    int r = num % base;
  5e:	00 00                	add    %al,(%eax)
  60:	b3 00                	mov    $0x0,%bl
  62:	00 00                	add    %al,(%eax)
  64:	02 00                	add    (%eax),%al
  66:	74 04                	je     6c <.debug_loc+0x6c>
	...
    if (r < 0)
  70:	b3 00                	mov    $0x0,%bl
    {
        r += base;
  72:	00 00                	add    %al,(%eax)
  74:	b4 00                	mov    $0x0,%ah
  76:	00 00                	add    %al,(%eax)
        --n;
  78:	02 00                	add    (%eax),%al
  7a:	74 04                	je     80 <.debug_loc+0x80>
    }

    if (num >= base)
  7c:	b4 00                	mov    $0x0,%ah
  7e:	00 00                	add    %al,(%eax)
  80:	b6 00                	mov    $0x0,%dh
  82:	00 00                	add    %al,(%eax)
        parse_num(buf, n, base);
  84:	02 00                	add    (%eax),%al
  86:	74 08                	je     90 <.debug_loc+0x90>
  88:	b6 00                	mov    $0x0,%dh
  8a:	00 00                	add    %al,(%eax)
  8c:	fc                   	cld    
  8d:	00 00                	add    %al,(%eax)
  8f:	00 02                	add    %al,(%edx)
  91:	00 75 08             	add    %dh,0x8(%ebp)
  94:	fc                   	cld    
  95:	00 00                	add    %al,(%eax)
  97:	00 fd                	add    %bh,%ch
  99:	00 00                	add    %al,(%eax)
  9b:	00 02                	add    %al,(%edx)

    *buf++ = "0123456789"[r];
  9d:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
  a1:	00 00                	add    %al,(%eax)
  a3:	00 00                	add    %al,(%eax)
  a5:	00 00                	add    %al,(%eax)
  a7:	00 fd                	add    %bh,%ch
  a9:	00 00                	add    %al,(%eax)
  ab:	00 fe                	add    %bh,%dh
  ad:	00 00                	add    %al,(%eax)
  af:	00 02                	add    %al,(%edx)
}
  b1:	00 74 04 fe          	add    %dh,-0x2(%esp,%eax,1)

int printk_get_level(const char *buffer)
{
  b5:	00 00                	add    %al,(%eax)
    if (buffer[0] == KERN_SOH_ASCII && buffer[1])
  b7:	00 00                	add    %al,(%eax)
  b9:	01 00                	add    %eax,(%eax)
  bb:	00 02                	add    %al,(%edx)
  bd:	00 74 08 00          	add    %dh,0x0(%eax,%ecx,1)
  c1:	01 00                	add    %eax,(%eax)
  c3:	00 28                	add    %ch,(%eax)
  c5:	03 00                	add    (%eax),%eax
  c7:	00 02                	add    %al,(%edx)
  c9:	00 75 08             	add    %dh,0x8(%ebp)
  cc:	28 03                	sub    %al,(%ebx)
    {
        switch (buffer[1])
  ce:	00 00                	add    %al,(%eax)
  d0:	29 03                	sub    %eax,(%ebx)
  d2:	00 00                	add    %al,(%eax)
  d4:	02 00                	add    (%eax),%al
  d6:	74 04                	je     dc <.debug_loc+0xdc>
	...
  e0:	29 03                	sub    %eax,(%ebx)
  e2:	00 00                	add    %al,(%eax)
  e4:	2a 03                	sub    (%ebx),%al
  e6:	00 00                	add    %al,(%eax)
        case '4':
        case '5':
        case '6':
        case '7':
        case 'd':
            return buffer[1];
  e8:	02 00                	add    (%eax),%al
  ea:	74 04                	je     f0 <.debug_loc+0xf0>
  ec:	2a 03                	sub    (%ebx),%al
  ee:	00 00                	add    %al,(%eax)
  f0:	2c 03                	sub    $0x3,%al
  f2:	00 00                	add    %al,(%eax)
  f4:	02 00                	add    (%eax),%al
        }
    }

    return 0;
  f6:	74 08                	je     100 <.debug_loc+0x100>
  f8:	2c 03                	sub    $0x3,%al
  fa:	00 00                	add    %al,(%eax)
}
  fc:	62 03                	bound  %eax,(%ebx)

int vsprintf(char *buf, const char *fmt, va_list args)
{
  fe:	00 00                	add    %al,(%eax)
 100:	02 00                	add    (%eax),%al
 102:	75 08                	jne    10c <.debug_loc+0x10c>
    int i;
    int index;
    char *s;

    index = 0;
 104:	62 03                	bound  %eax,(%ebx)
 106:	00 00                	add    %al,(%eax)
 108:	63 03                	arpl   %ax,(%ebx)

    for (i = 0; fmt[i] != '\0'; ++i)
 10a:	00 00                	add    %al,(%eax)
 10c:	02 00                	add    (%eax),%al
 10e:	74 04                	je     114 <.debug_loc+0x114>
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:

#include <common/types.h>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
   0:	1c 00                	sbb    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
   6:	00 00                	add    %al,(%eax)
			6: R_386_32	.debug_info
    int i = 7;
   8:	00 00                	add    %al,(%eax)
   a:	04 00                	add    $0x0,%al
	...
			10: R_386_32	.text
    while (i-- >= 0)
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
  14:	63 03                	arpl   %ax,(%ebx)
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:

#include <common/types.h>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
   0:	1b 01                	sbb    (%ecx),%eax
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
   6:	8e 00                	mov    (%eax),%es
    int i = 7;
   8:	00 00                	add    %al,(%eax)
   a:	01 01                	add    %eax,(%ecx)
   c:	fb                   	sti    
   d:	0e                   	push   %cs
    while (i-- >= 0)
   e:	0d 00 01 01 01       	or     $0x1010100,%eax
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
  13:	01 00                	add    %eax,(%eax)
  15:	00 00                	add    %al,(%eax)
  17:	01 00                	add    %eax,(%eax)
  19:	00 01                	add    %al,(%ecx)
  1b:	2f                   	das    
  1c:	68 6f 6d 65 2f       	push   $0x2f656d6f
  21:	62 6c 65 73          	bound  %ebp,0x73(%ebp,%eiz,2)
  25:	73 65                	jae    8c <.debug_line+0x8c>
  27:	64                   	fs
  28:	2f                   	das    
  29:	50                   	push   %eax
  2a:	72 6f                	jb     9b <.debug_line+0x9b>
  2c:	67 72 61             	addr16 jb 90 <.debug_line+0x90>
  2f:	6d                   	insl   (%dx),%es:(%edi)
  30:	6f                   	outsl  %ds:(%esi),(%dx)
  31:	77 61                	ja     94 <.debug_line+0x94>
  33:	6e                   	outsb  %ds:(%esi),(%dx)
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
    int i = 7;
    while (i-- >= 0)
  34:	69 65 2f 62 6c 65 73 	imul   $0x73656c62,0x2f(%ebp),%esp
  3b:	73 4f                	jae    8c <.debug_line+0x8c>
  3d:	53                   	push   %ebx
  3e:	2f                   	das    
  3f:	65                   	gs
  40:	78 2f                	js     71 <.debug_line+0x71>
  42:	73 72                	jae    b6 <.debug_line+0xb6>
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
    }
}
  44:	63 2f                	arpl   %bp,(%edi)
  46:	63 6f 6d             	arpl   %bp,0x6d(%edi)
  49:	6d                   	insl   (%dx),%es:(%edi)

static void parse_num(char *buf, int num, int base)
{
  4a:	6f                   	outsl  %ds:(%esi),(%dx)
  4b:	6e                   	outsb  %ds:(%esi),(%dx)
  4c:	00 2f                	add    %ch,(%edi)
  4e:	68 6f 6d 65 2f       	push   $0x2f656d6f
    u32int n = num / base;
  53:	62 6c 65 73          	bound  %ebp,0x73(%ebp,%eiz,2)
  57:	73 65                	jae    be <.debug_line+0xbe>
  59:	64                   	fs
  5a:	2f                   	das    
  5b:	50                   	push   %eax
  5c:	72 6f                	jb     cd <.debug_line+0xcd>
    int r = num % base;
  5e:	67 72 61             	addr16 jb c2 <.debug_line+0xc2>
  61:	6d                   	insl   (%dx),%es:(%edi)
  62:	6f                   	outsl  %ds:(%esi),(%dx)
  63:	77 61                	ja     c6 <.debug_line+0xc6>
  65:	6e                   	outsb  %ds:(%esi),(%dx)
  66:	69 65 2f 62 6c 65 73 	imul   $0x73656c62,0x2f(%ebp),%esp
    if (r < 0)
  6d:	73 4f                	jae    be <.debug_line+0xbe>
  6f:	53                   	push   %ebx
  70:	2f                   	das    
  71:	65                   	gs
    {
        r += base;
  72:	78 2f                	js     a3 <.debug_line+0xa3>
  74:	69 6e 63 2f 63 6f 6d 	imul   $0x6d6f632f,0x63(%esi),%ebp
        --n;
  7b:	6d                   	insl   (%dx),%es:(%edi)
    }

    if (num >= base)
  7c:	6f                   	outsl  %ds:(%esi),(%dx)
  7d:	6e                   	outsb  %ds:(%esi),(%dx)
  7e:	00 00                	add    %al,(%eax)
  80:	70 72                	jo     f4 <.debug_line+0xf4>
  82:	69 6e 74 6b 2e 63 00 	imul   $0x632e6b,0x74(%esi),%ebp
        parse_num(buf, n, base);
  89:	01 00                	add    %eax,(%eax)
  8b:	00 74 79 70          	add    %dh,0x70(%ecx,%edi,2)
  8f:	65                   	gs
  90:	73 2e                	jae    c0 <.debug_line+0xc0>
  92:	68 00 02 00 00       	push   $0x200
  97:	00 00                	add    %al,(%eax)
  99:	05 02 00 00 00       	add    $0x2,%eax
			9b: R_386_32	.text

    *buf++ = "0123456789"[r];
  9e:	00 18                	add    %bl,(%eax)
  a0:	75 75                	jne    117 <.debug_line+0x117>
  a2:	30 00                	xor    %al,(%eax)
  a4:	02 04 01             	add    (%ecx,%eax,1),%al
  a7:	02 24 10             	add    (%eax,%edx,1),%ah
  aa:	f6 69 67             	imulb  0x67(%ecx)
  ad:	d7                   	xlat   %ds:(%ebx)
  ae:	d7                   	xlat   %ds:(%ebx)
  af:	68 67 4d 83 08       	push   $0x8834d67
}

int printk_get_level(const char *buffer)
{
  b4:	84 08                	test   %cl,(%eax)
    if (buffer[0] == KERN_SOH_ASCII && buffer[1])
  b6:	3d 31 3d 00 02       	cmp    $0x2003d31,%eax
  bb:	04 01                	add    $0x1,%al
  bd:	06                   	push   %es
  be:	9e                   	sahf   
  bf:	06                   	push   %es
  c0:	ca 03 0b             	lret   $0xb03
  c3:	08 9e da 59 31 6b    	or     %bl,0x6b3159da(%esi)
  c9:	76 bc                	jbe    87 <.debug_line+0x87>
  cb:	00 02                	add    %al,(%edx)
    {
        switch (buffer[1])
  cd:	04 01                	add    $0x1,%al
  cf:	06                   	push   %es
  d0:	e4 06                	in     $0x6,%al
  d2:	e6 08                	out    %al,$0x8
  d4:	83 5a 08 30          	sbbl   $0x30,0x8(%edx)
  d8:	02 4b 15             	add    0x15(%ebx),%cl
  db:	c9                   	leave  
  dc:	30 00                	xor    %al,(%eax)
  de:	02 04 01             	add    (%ecx,%eax,1),%al
  e1:	08 72 a2             	or     %dh,-0x5e(%edx)
  e4:	5b                   	pop    %ebx
  e5:	08 83 32 08 9f 31    	or     %al,0x319f0832(%ebx)
        case '4':
        case '5':
        case '6':
        case '7':
        case 'd':
            return buffer[1];
  eb:	02 23                	add    (%ebx),%ah
  ed:	13 31                	adc    (%ecx),%esi
  ef:	e5 31                	in     $0x31,%eax
  f1:	08 83 23 5b 02 23    	or     %al,0x23025b23(%ebx)
        }
    }

    return 0;
  f7:	15 08 14 08 14       	adc    $0x14081408,%eax
}
  fc:	08 14 08             	or     %dl,(%eax,%ecx,1)

int vsprintf(char *buf, const char *fmt, va_list args)
{
  ff:	14 08                	adc    $0x8,%al
 101:	14 03                	adc    $0x3,%al
    int i;
    int index;
    char *s;

    index = 0;
 103:	47                   	inc    %edi
 104:	f2 00 02             	repnz add %al,(%edx)
 107:	04 01                	add    $0x1,%al
 109:	06                   	push   %es

    for (i = 0; fmt[i] != '\0'; ++i)
 10a:	4a                   	dec    %edx
 10b:	06                   	push   %es
 10c:	03 3d 08 2e ad 76    	add    0x76ad2e08,%edi
 112:	3d 31 95 67 08       	cmp    $0x8679531,%eax
    {
        if ((fmt[i] != '%') && (fmt[i] != '\\'))
 117:	d7                   	xlat   %ds:(%ebx)
 118:	78 3d                	js     157 <vsprintf+0x5a>
 11a:	02 02                	add    (%edx),%al
 11c:	00 01                	add    %al,(%ecx)
 11e:	01                   	.byte 0x1

Disassembly of section .debug_str:

00000000 <.debug_str>:

#include <common/types.h>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
   0:	75 6e                	jne    70 <.debug_str+0x70>
   2:	73 69                	jae    6d <.debug_str+0x6d>
   4:	67 6e                	outsb  %ds:(%si),(%dx)
   6:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
    int i = 7;
   b:	74 00                	je     d <.debug_str+0xd>
   d:	75 33                	jne    42 <.debug_str+0x42>
    while (i-- >= 0)
   f:	32 69 6e             	xor    0x6e(%ecx),%ch
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
  12:	74 00                	je     14 <.debug_str+0x14>
  14:	47                   	inc    %edi
  15:	4e                   	dec    %esi
  16:	55                   	push   %ebp
  17:	20 43 20             	and    %al,0x20(%ebx)
  1a:	34 2e                	xor    $0x2e,%al
  1c:	37                   	aaa    
  1d:	2e 33 00             	xor    %cs:(%eax),%eax
  20:	70 72                	jo     94 <.debug_str+0x94>
  22:	69 6e 74 6b 5f 67 65 	imul   $0x65675f6b,0x74(%esi),%ebp
  29:	74 5f                	je     8a <.debug_str+0x8a>
  2b:	6c                   	insb   (%dx),%es:(%edi)
  2c:	65                   	gs
  2d:	76 65                	jbe    94 <.debug_str+0x94>
  2f:	6c                   	insb   (%dx),%es:(%edi)
  30:	00 70 61             	add    %dh,0x61(%eax)
  33:	72 73                	jb     a8 <.debug_str+0xa8>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
    int i = 7;
    while (i-- >= 0)
  35:	65                   	gs
  36:	5f                   	pop    %edi
  37:	6e                   	outsb  %ds:(%esi),(%dx)
  38:	75 6d                	jne    a7 <.debug_str+0xa7>
  3a:	00 62 61             	add    %ah,0x61(%edx)
  3d:	73 65                	jae    a4 <.debug_str+0xa4>
  3f:	00 70 61             	add    %dh,0x61(%eax)
  42:	72 73                	jb     b7 <.debug_str+0xb7>
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
    }
}
  44:	65                   	gs
  45:	5f                   	pop    %edi
  46:	68 65 78 00 69       	push   $0x69007865

static void parse_num(char *buf, int num, int base)
{
  4b:	6e                   	outsb  %ds:(%esi),(%dx)
  4c:	64                   	fs
  4d:	65                   	gs
  4e:	78 00                	js     50 <.debug_str+0x50>
    u32int n = num / base;
  50:	76 73                	jbe    c5 <.debug_str+0xc5>
  52:	70 72                	jo     c6 <.debug_str+0xc6>
  54:	69 6e 74 66 00 75 6e 	imul   $0x6e750066,0x74(%esi),%ebp
  5b:	73 69                	jae    c6 <.debug_str+0xc6>
  5d:	67 6e                	outsb  %ds:(%si),(%dx)
    int r = num % base;
  5f:	65 64 20 63 68       	gs and %ah,%fs:%gs:0x68(%ebx)
  64:	61                   	popa   
  65:	72 00                	jb     67 <.debug_str+0x67>
  67:	63 68 61             	arpl   %bp,0x61(%eax)
  6a:	72 00                	jb     6c <.debug_str+0x6c>
    if (r < 0)
  6c:	76 61                	jbe    cf <.debug_str+0xcf>
  6e:	5f                   	pop    %edi
  6f:	6c                   	insb   (%dx),%es:(%edi)
  70:	69 73 74 00 2f 68 6f 	imul   $0x6f682f00,0x74(%ebx),%esi
    {
        r += base;
  77:	6d                   	insl   (%dx),%es:(%edi)
        --n;
  78:	65                   	gs
  79:	2f                   	das    
  7a:	62 6c 65 73          	bound  %ebp,0x73(%ebp,%eiz,2)
    }

    if (num >= base)
  7e:	73 65                	jae    e5 <printk_get_level+0x32>
  80:	64                   	fs
  81:	2f                   	das    
  82:	50                   	push   %eax
  83:	72 6f                	jb     f4 <printk_get_level+0x41>
        parse_num(buf, n, base);
  85:	67 72 61             	addr16 jb e9 <printk_get_level+0x36>
  88:	6d                   	insl   (%dx),%es:(%edi)
  89:	6f                   	outsl  %ds:(%esi),(%dx)
  8a:	77 61                	ja     ed <printk_get_level+0x3a>
  8c:	6e                   	outsb  %ds:(%esi),(%dx)
  8d:	69 65 2f 62 6c 65 73 	imul   $0x73656c62,0x2f(%ebp),%esp
  94:	73 4f                	jae    e5 <printk_get_level+0x32>
  96:	53                   	push   %ebx
  97:	2f                   	das    
  98:	65                   	gs
  99:	78 2f                	js     ca <.debug_str+0xca>
  9b:	73 72                	jae    10f <vsprintf+0x12>

    *buf++ = "0123456789"[r];
  9d:	63 2f                	arpl   %bp,(%edi)
  9f:	63 6f 6d             	arpl   %bp,0x6d(%edi)
  a2:	6d                   	insl   (%dx),%es:(%edi)
  a3:	6f                   	outsl  %ds:(%esi),(%dx)
  a4:	6e                   	outsb  %ds:(%esi),(%dx)
  a5:	2f                   	das    
  a6:	70 72                	jo     11a <vsprintf+0x1d>
  a8:	69 6e 74 6b 2e 63 00 	imul   $0x632e6b,0x74(%esi),%ebp
  af:	61                   	popa   
  b0:	72 67                	jb     119 <vsprintf+0x1c>
}
  b2:	73 00                	jae    b4 <.debug_str+0xb4>

int printk_get_level(const char *buffer)
{
  b4:	73 68                	jae    11e <vsprintf+0x21>
    if (buffer[0] == KERN_SOH_ASCII && buffer[1])
  b6:	6f                   	outsl  %ds:(%esi),(%dx)
  b7:	72 74                	jb     12d <vsprintf+0x30>
  b9:	20 75 6e             	and    %dh,0x6e(%ebp)
  bc:	73 69                	jae    127 <vsprintf+0x2a>
  be:	67 6e                	outsb  %ds:(%si),(%dx)
  c0:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
  c5:	74 00                	je     c7 <.debug_str+0xc7>
  c7:	70 72                	jo     13b <vsprintf+0x3e>
  c9:	69 6e 74 6b 00 62 75 	imul   $0x7562006b,0x74(%esi),%ebp
    {
        switch (buffer[1])
  d0:	66                   	data16
  d1:	66                   	data16
  d2:	65                   	gs
  d3:	72 00                	jb     d5 <.debug_str+0xd5>
  d5:	73 69                	jae    140 <vsprintf+0x43>
  d7:	7a 65                	jp     13e <vsprintf+0x41>
  d9:	74 79                	je     154 <vsprintf+0x57>
  db:	70 65                	jo     142 <vsprintf+0x45>
	...

Disassembly of section .comment:

00000000 <.comment>:

#include <common/types.h>
#include <common/printk.h>

static void parse_hex(char *buf, int num)
{
   0:	00 47 43             	add    %al,0x43(%edi)
   3:	43                   	inc    %ebx
   4:	3a 20                	cmp    (%eax),%ah
   6:	28 44 65 62          	sub    %al,0x62(%ebp,%eiz,2)
    int i = 7;
   a:	69 61 6e 20 34 2e 37 	imul   $0x372e3420,0x6e(%ecx),%esp
    while (i-- >= 0)
    {
        *buf++ = "0123456789abcdef"[(num >> (i * 4)) & 0x0f];
  11:	2e 33 2d 34 29 20 34 	xor    %cs:0x34202934,%ebp
  18:	2e                   	cs
  19:	37                   	aaa    
  1a:	2e 33 00             	xor    %cs:(%eax),%eax

Disassembly of section .eh_frame:

00000000 <.eh_frame>:
   0:	14 00                	adc    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	00 00                	add    %al,(%eax)
   6:	00 00                	add    %al,(%eax)
   8:	01 7a 52             	add    %edi,0x52(%edx)
   b:	00 01                	add    %al,(%ecx)
   d:	7c 08                	jl     17 <.eh_frame+0x17>
   f:	01 1b                	add    %ebx,(%ebx)
  11:	0c 04                	or     $0x4,%al
  13:	04 88                	add    $0x88,%al
  15:	01 00                	add    %eax,(%eax)
  17:	00 20                	add    %ah,(%eax)
  19:	00 00                	add    %al,(%eax)
  1b:	00 1c 00             	add    %bl,(%eax,%eax,1)
  1e:	00 00                	add    %al,(%eax)
  20:	00 00                	add    %al,(%eax)
			20: R_386_PC32	.text
  22:	00 00                	add    %al,(%eax)
  24:	4a                   	dec    %edx
  25:	00 00                	add    %al,(%eax)
  27:	00 00                	add    %al,(%eax)
  29:	41                   	inc    %ecx
  2a:	0e                   	push   %cs
  2b:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  31:	44                   	inc    %esp
  32:	83 03 02             	addl   $0x2,(%ebx)
  35:	41                   	inc    %ecx
  36:	c3                   	ret    
  37:	41                   	inc    %ecx
  38:	c5 0c 04             	lds    (%esp,%eax,1),%ecx
  3b:	04 1c                	add    $0x1c,%al
  3d:	00 00                	add    %al,(%eax)
  3f:	00 40 00             	add    %al,0x0(%eax)
  42:	00 00                	add    %al,(%eax)
  44:	4a                   	dec    %edx
			44: R_386_PC32	.text
  45:	00 00                	add    %al,(%eax)
  47:	00 69 00             	add    %ch,0x0(%ecx)
  4a:	00 00                	add    %al,(%eax)
  4c:	00 41 0e             	add    %al,0xe(%ecx)
  4f:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  55:	02 65 c5             	add    -0x3b(%ebp),%ah
  58:	0c 04                	or     $0x4,%al
  5a:	04 00                	add    $0x0,%al
  5c:	1c 00                	sbb    $0x0,%al
  5e:	00 00                	add    %al,(%eax)
  60:	60                   	pusha  
  61:	00 00                	add    %al,(%eax)
  63:	00 b3 00 00 00 4a    	add    %dh,0x4a000000(%ebx)
			64: R_386_PC32	.text
  69:	00 00                	add    %al,(%eax)
  6b:	00 00                	add    %al,(%eax)
  6d:	41                   	inc    %ecx
  6e:	0e                   	push   %cs
  6f:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  75:	02 46 c5             	add    -0x3b(%esi),%al
  78:	0c 04                	or     $0x4,%al
  7a:	04 00                	add    $0x0,%al
  7c:	1c 00                	sbb    $0x0,%al
  7e:	00 00                	add    %al,(%eax)
  80:	80 00 00             	addb   $0x0,(%eax)
  83:	00 fd                	add    %bh,%ch
			84: R_386_PC32	.text
  85:	00 00                	add    %al,(%eax)
  87:	00 2c 02             	add    %ch,(%edx,%eax,1)
  8a:	00 00                	add    %al,(%eax)
  8c:	00 41 0e             	add    %al,0xe(%ecx)
  8f:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  95:	03 28                	add    (%eax),%ebp
  97:	02 c5                	add    %ch,%al
  99:	0c 04                	or     $0x4,%al
  9b:	04 1c                	add    $0x1c,%al
  9d:	00 00                	add    %al,(%eax)
  9f:	00 a0 00 00 00 29    	add    %ah,0x29000000(%eax)
			a4: R_386_PC32	.text
  a5:	03 00                	add    (%eax),%eax
  a7:	00 3a                	add    %bh,(%edx)
  a9:	00 00                	add    %al,(%eax)
  ab:	00 00                	add    %al,(%eax)
  ad:	41                   	inc    %ecx
  ae:	0e                   	push   %cs
  af:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  b5:	76 c5                	jbe    7c <.eh_frame+0x7c>
  b7:	0c 04                	or     $0x4,%al
  b9:	04 00                	add    $0x0,%al
	...
