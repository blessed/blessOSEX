
/home/blessed/Programowanie/blessOS/ex/src/console/console.o:     file format elf32-i386


Disassembly of section .text:

00000000 <scroll_down>:
#include <console/console.h>

static int csr_x, csr_y;

static void scroll_down()
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
    int i;
    u16int *vga_mem = (u16int *)VRAM_START;
   6:	c7 45 f0 00 80 0b 00 	movl   $0xb8000,-0x10(%ebp)
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);
   d:	66 c7 45 ee 20 0f    	movw   $0xf20,-0x12(%ebp)

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
  13:	8b 45 f0             	mov    -0x10(%ebp),%eax
  16:	05 a0 00 00 00       	add    $0xa0,%eax
  1b:	c7 44 24 08 00 0f 00 	movl   $0xf00,0x8(%esp)
  22:	00 
  23:	89 44 24 04          	mov    %eax,0x4(%esp)
  27:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2a:	89 04 24             	mov    %eax,(%esp)
  2d:	e8 fc ff ff ff       	call   2e <scroll_down+0x2e>
			2e: R_386_PC32	memcpy
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  39:	eb 1c                	jmp    57 <scroll_down+0x57>
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
  3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  3e:	05 80 07 00 00       	add    $0x780,%eax
  43:	01 c0                	add    %eax,%eax
  45:	89 c2                	mov    %eax,%edx
  47:	8b 45 f0             	mov    -0x10(%ebp),%eax
  4a:	01 c2                	add    %eax,%edx
  4c:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
  50:	66 89 02             	mov    %ax,(%edx)
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  53:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  57:	83 7d f4 4f          	cmpl   $0x4f,-0xc(%ebp)
  5b:	7e de                	jle    3b <scroll_down+0x3b>
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
    }
}
  5d:	c9                   	leave  
  5e:	c3                   	ret    

0000005f <set_cursor>:

void set_cursor(int x, int y)
{
  5f:	55                   	push   %ebp
  60:	89 e5                	mov    %esp,%ebp
  62:	83 ec 28             	sub    $0x28,%esp
    u16int position;
    csr_x = x;
  65:	8b 45 08             	mov    0x8(%ebp),%eax
  68:	a3 00 00 00 00       	mov    %eax,0x0
			69: R_386_32	.bss
    csr_y = y;
  6d:	8b 45 0c             	mov    0xc(%ebp),%eax
  70:	a3 04 00 00 00       	mov    %eax,0x4
			71: R_386_32	.bss

    position = csr_y * CONSOLE_WIDTH + csr_x;
  75:	a1 04 00 00 00       	mov    0x4,%eax
			76: R_386_32	.bss
  7a:	89 c2                	mov    %eax,%edx
  7c:	89 d0                	mov    %edx,%eax
  7e:	c1 e0 02             	shl    $0x2,%eax
  81:	01 d0                	add    %edx,%eax
  83:	c1 e0 04             	shl    $0x4,%eax
  86:	89 c2                	mov    %eax,%edx
  88:	a1 00 00 00 00       	mov    0x0,%eax
			89: R_386_32	.bss
  8d:	01 d0                	add    %edx,%eax
  8f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

    outb(0x0f, 0x3d4);
  93:	c7 44 24 04 d4 03 00 	movl   $0x3d4,0x4(%esp)
  9a:	00 
  9b:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  a2:	e8 fc ff ff ff       	call   a3 <set_cursor+0x44>
			a3: R_386_PC32	outb
    outb((u8int)(position & 0xff), 0x3d5);
  a7:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  ab:	0f b6 c0             	movzbl %al,%eax
  ae:	c7 44 24 04 d5 03 00 	movl   $0x3d5,0x4(%esp)
  b5:	00 
  b6:	89 04 24             	mov    %eax,(%esp)
  b9:	e8 fc ff ff ff       	call   ba <set_cursor+0x5b>
			ba: R_386_PC32	outb
    outb(0x0e, 0x3d4);
  be:	c7 44 24 04 d4 03 00 	movl   $0x3d4,0x4(%esp)
  c5:	00 
  c6:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  cd:	e8 fc ff ff ff       	call   ce <set_cursor+0x6f>
			ce: R_386_PC32	outb
    outb((u8int)((position >> 8) & 0xff), 0x3d5);
  d2:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  d6:	66 c1 e8 08          	shr    $0x8,%ax
  da:	0f b6 c0             	movzbl %al,%eax
  dd:	c7 44 24 04 d5 03 00 	movl   $0x3d5,0x4(%esp)
  e4:	00 
  e5:	89 04 24             	mov    %eax,(%esp)
  e8:	e8 fc ff ff ff       	call   e9 <set_cursor+0x8a>
			e9: R_386_PC32	outb
}
  ed:	c9                   	leave  
  ee:	c3                   	ret    

000000ef <get_cursor>:

void get_cursor(int *x, int *y)
{
  ef:	55                   	push   %ebp
  f0:	89 e5                	mov    %esp,%ebp
    *x = csr_x;
  f2:	8b 15 00 00 00 00    	mov    0x0,%edx
			f4: R_386_32	.bss
  f8:	8b 45 08             	mov    0x8(%ebp),%eax
  fb:	89 10                	mov    %edx,(%eax)
    *y = csr_y;
  fd:	8b 15 04 00 00 00    	mov    0x4,%edx
			ff: R_386_32	.bss
 103:	8b 45 0c             	mov    0xc(%ebp),%eax
 106:	89 10                	mov    %edx,(%eax)
}
 108:	5d                   	pop    %ebp
 109:	c3                   	ret    

0000010a <console_init>:

void console_init()
{
 10a:	55                   	push   %ebp
 10b:	89 e5                	mov    %esp,%ebp
 10d:	83 ec 18             	sub    $0x18,%esp
    clear_screen();
 110:	e8 fc ff ff ff       	call   111 <console_init+0x7>
			111: R_386_PC32	clear_screen

    set_cursor(0, 0);
 115:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 11c:	00 
 11d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 124:	e8 fc ff ff ff       	call   125 <console_init+0x1b>
			125: R_386_PC32	set_cursor
}
 129:	c9                   	leave  
 12a:	c3                   	ret    

0000012b <clear_screen>:

void clear_screen()
{
 12b:	55                   	push   %ebp
 12c:	89 e5                	mov    %esp,%ebp
 12e:	83 ec 10             	sub    $0x10,%esp
    u16int *vga_mem = (u16int *)VRAM_START;
 131:	c7 45 fc 00 80 0b 00 	movl   $0xb8000,-0x4(%ebp)
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);
 138:	66 c7 45 f6 20 0f    	movw   $0xf20,-0xa(%ebp)

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
 13e:	c7 45 f8 d0 07 00 00 	movl   $0x7d0,-0x8(%ebp)
    for (; count > 0; count--)
 145:	eb 12                	jmp    159 <clear_screen+0x2e>
        *vga_mem++ = blankchar;
 147:	8b 45 fc             	mov    -0x4(%ebp),%eax
 14a:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
 14e:	66 89 10             	mov    %dx,(%eax)
 151:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
{
    u16int *vga_mem = (u16int *)VRAM_START;
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
    for (; count > 0; count--)
 155:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
 159:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 15d:	7f e8                	jg     147 <clear_screen+0x1c>
        *vga_mem++ = blankchar;
}
 15f:	c9                   	leave  
 160:	c3                   	ret    

00000161 <print_c>:

void print_c(char c, CONSOLE_COLOR fg, CONSOLE_COLOR bg)
{
 161:	55                   	push   %ebp
 162:	89 e5                	mov    %esp,%ebp
 164:	83 ec 38             	sub    $0x38,%esp
 167:	8b 45 08             	mov    0x8(%ebp),%eax
 16a:	88 45 e4             	mov    %al,-0x1c(%ebp)
    u8int *dest = (u8int *)(VRAM_START + csr_y * VRAM_LINE + csr_x * CONSOLE_CHAR_SIZE);
 16d:	8b 15 04 00 00 00    	mov    0x4,%edx
			16f: R_386_32	.bss
 173:	89 d0                	mov    %edx,%eax
 175:	c1 e0 02             	shl    $0x2,%eax
 178:	01 d0                	add    %edx,%eax
 17a:	c1 e0 05             	shl    $0x5,%eax
 17d:	8d 90 00 80 0b 00    	lea    0xb8000(%eax),%edx
 183:	a1 00 00 00 00       	mov    0x0,%eax
			184: R_386_32	.bss
 188:	01 c0                	add    %eax,%eax
 18a:	01 d0                	add    %edx,%eax
 18c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    u8int attr = (u8int)(bg << 4 | fg );
 18f:	8b 45 10             	mov    0x10(%ebp),%eax
 192:	89 c2                	mov    %eax,%edx
 194:	c1 e2 04             	shl    $0x4,%edx
 197:	8b 45 0c             	mov    0xc(%ebp),%eax
 19a:	09 d0                	or     %edx,%eax
 19c:	88 45 f3             	mov    %al,-0xd(%ebp)

    switch (c)
 19f:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
 1a3:	83 f8 09             	cmp    $0x9,%eax
 1a6:	74 66                	je     20e <print_c+0xad>
 1a8:	83 f8 09             	cmp    $0x9,%eax
 1ab:	7f 0e                	jg     1bb <print_c+0x5a>
 1ad:	83 f8 08             	cmp    $0x8,%eax
 1b0:	0f 84 c4 00 00 00    	je     27a <print_c+0x119>
 1b6:	e9 18 01 00 00       	jmp    2d3 <print_c+0x172>
 1bb:	83 f8 0a             	cmp    $0xa,%eax
 1be:	74 3e                	je     1fe <print_c+0x9d>
 1c0:	83 f8 0d             	cmp    $0xd,%eax
 1c3:	0f 85 0a 01 00 00    	jne    2d3 <print_c+0x172>
    {
    case '\r':
        csr_x = 0;
 1c9:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 1d0:	00 00 00 
			1cb: R_386_32	.bss
        break;
 1d3:	e9 23 01 00 00       	jmp    2fb <print_c+0x19a>
    case '\n':
        for (; csr_x < CONSOLE_WIDTH; ++csr_x)
        {
            *dest++ = BLANK_CHAR;
 1d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1db:	c6 00 20             	movb   $0x20,(%eax)
 1de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            *dest++ = attr;
 1e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 1e5:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
 1e9:	88 10                	mov    %dl,(%eax)
 1eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    {
    case '\r':
        csr_x = 0;
        break;
    case '\n':
        for (; csr_x < CONSOLE_WIDTH; ++csr_x)
 1ef:	a1 00 00 00 00       	mov    0x0,%eax
			1f0: R_386_32	.bss
 1f4:	83 c0 01             	add    $0x1,%eax
 1f7:	a3 00 00 00 00       	mov    %eax,0x0
			1f8: R_386_32	.bss
 1fc:	eb 01                	jmp    1ff <print_c+0x9e>
 1fe:	90                   	nop
 1ff:	a1 00 00 00 00       	mov    0x0,%eax
			200: R_386_32	.bss
 204:	83 f8 4f             	cmp    $0x4f,%eax
 207:	7e cf                	jle    1d8 <print_c+0x77>
        {
            *dest++ = BLANK_CHAR;
            *dest++ = attr;
        }
        break;
 209:	e9 ed 00 00 00       	jmp    2fb <print_c+0x19a>
    case '\t':
        c = csr_x + TAB_WIDTH - (csr_x % TAB_WIDTH);
 20e:	a1 00 00 00 00       	mov    0x0,%eax
			20f: R_386_32	.bss
 213:	89 c1                	mov    %eax,%ecx
 215:	a1 00 00 00 00       	mov    0x0,%eax
			216: R_386_32	.bss
 21a:	89 c2                	mov    %eax,%edx
 21c:	c1 fa 1f             	sar    $0x1f,%edx
 21f:	c1 ea 1e             	shr    $0x1e,%edx
 222:	01 d0                	add    %edx,%eax
 224:	83 e0 03             	and    $0x3,%eax
 227:	29 d0                	sub    %edx,%eax
 229:	89 ca                	mov    %ecx,%edx
 22b:	29 c2                	sub    %eax,%edx
 22d:	89 d0                	mov    %edx,%eax
 22f:	83 c0 04             	add    $0x4,%eax
 232:	88 45 e4             	mov    %al,-0x1c(%ebp)
        c = c < CONSOLE_WIDTH ? c : CONSOLE_WIDTH;
 235:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 239:	3c 50                	cmp    $0x50,%al
 23b:	7e 05                	jle    242 <print_c+0xe1>
 23d:	b8 50 00 00 00       	mov    $0x50,%eax
 242:	88 45 e4             	mov    %al,-0x1c(%ebp)
        for (; csr_x < c; ++csr_x)
 245:	eb 21                	jmp    268 <print_c+0x107>
        {
            *dest++ = (u8int)BLANK_CHAR;
 247:	8b 45 f4             	mov    -0xc(%ebp),%eax
 24a:	c6 00 20             	movb   $0x20,(%eax)
 24d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            *dest++ = (u8int)BLANK_ATTR;
 251:	8b 45 f4             	mov    -0xc(%ebp),%eax
 254:	c6 00 07             	movb   $0x7,(%eax)
 257:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        }
        break;
    case '\t':
        c = csr_x + TAB_WIDTH - (csr_x % TAB_WIDTH);
        c = c < CONSOLE_WIDTH ? c : CONSOLE_WIDTH;
        for (; csr_x < c; ++csr_x)
 25b:	a1 00 00 00 00       	mov    0x0,%eax
			25c: R_386_32	.bss
 260:	83 c0 01             	add    $0x1,%eax
 263:	a3 00 00 00 00       	mov    %eax,0x0
			264: R_386_32	.bss
 268:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
 26c:	a1 00 00 00 00       	mov    0x0,%eax
			26d: R_386_32	.bss
 271:	39 c2                	cmp    %eax,%edx
 273:	7f d2                	jg     247 <print_c+0xe6>
        {
            *dest++ = (u8int)BLANK_CHAR;
            *dest++ = (u8int)BLANK_ATTR;
        }
        break;
 275:	e9 81 00 00 00       	jmp    2fb <print_c+0x19a>
    case '\b':
        if ((!csr_x) && (!csr_y))
 27a:	a1 00 00 00 00       	mov    0x0,%eax
			27b: R_386_32	.bss
 27f:	85 c0                	test   %eax,%eax
 281:	75 0d                	jne    290 <print_c+0x12f>
 283:	a1 04 00 00 00       	mov    0x4,%eax
			284: R_386_32	.bss
 288:	85 c0                	test   %eax,%eax
 28a:	0f 84 b6 00 00 00    	je     346 <print_c+0x1e5>
            return;

        if (!csr_x)
 290:	a1 00 00 00 00       	mov    0x0,%eax
			291: R_386_32	.bss
 295:	85 c0                	test   %eax,%eax
 297:	75 19                	jne    2b2 <print_c+0x151>
        {
            csr_x = CONSOLE_WIDTH - 1;
 299:	c7 05 00 00 00 00 4f 	movl   $0x4f,0x0
 2a0:	00 00 00 
			29b: R_386_32	.bss
            --csr_y;
 2a3:	a1 04 00 00 00       	mov    0x4,%eax
			2a4: R_386_32	.bss
 2a8:	83 e8 01             	sub    $0x1,%eax
 2ab:	a3 04 00 00 00       	mov    %eax,0x4
			2ac: R_386_32	.bss
 2b0:	eb 0d                	jmp    2bf <print_c+0x15e>
        } else
            --csr_x;
 2b2:	a1 00 00 00 00       	mov    0x0,%eax
			2b3: R_386_32	.bss
 2b7:	83 e8 01             	sub    $0x1,%eax
 2ba:	a3 00 00 00 00       	mov    %eax,0x0
			2bb: R_386_32	.bss

        dest[-1] = (u8int)BLANK_ATTR;
 2bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2c2:	83 e8 01             	sub    $0x1,%eax
 2c5:	c6 00 07             	movb   $0x7,(%eax)
        dest[-2] = (u8int)BLANK_CHAR;
 2c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2cb:	83 e8 02             	sub    $0x2,%eax
 2ce:	c6 00 20             	movb   $0x20,(%eax)
        break;
 2d1:	eb 28                	jmp    2fb <print_c+0x19a>
    default:
        *dest++ = c;
 2d3:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
 2d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2da:	88 10                	mov    %dl,(%eax)
 2dc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        *dest++ = attr;
 2e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2e3:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
 2e7:	88 10                	mov    %dl,(%eax)
 2e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        ++csr_x;
 2ed:	a1 00 00 00 00       	mov    0x0,%eax
			2ee: R_386_32	.bss
 2f2:	83 c0 01             	add    $0x1,%eax
 2f5:	a3 00 00 00 00       	mov    %eax,0x0
			2f6: R_386_32	.bss
        break;
 2fa:	90                   	nop
    }

    if (csr_x >= CONSOLE_WIDTH)
 2fb:	a1 00 00 00 00       	mov    0x0,%eax
			2fc: R_386_32	.bss
 300:	83 f8 4f             	cmp    $0x4f,%eax
 303:	7e 28                	jle    32d <print_c+0x1cc>
    {
        csr_x = 0;
 305:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 30c:	00 00 00 
			307: R_386_32	.bss
        if (csr_y < (CONSOLE_HEIGHT - 1))
 30f:	a1 04 00 00 00       	mov    0x4,%eax
			310: R_386_32	.bss
 314:	83 f8 17             	cmp    $0x17,%eax
 317:	7f 0f                	jg     328 <print_c+0x1c7>
            csr_y++;
 319:	a1 04 00 00 00       	mov    0x4,%eax
			31a: R_386_32	.bss
 31e:	83 c0 01             	add    $0x1,%eax
 321:	a3 04 00 00 00       	mov    %eax,0x4
			322: R_386_32	.bss
 326:	eb 05                	jmp    32d <print_c+0x1cc>
        else
            scroll_down();
 328:	e8 d3 fc ff ff       	call   0 <scroll_down>
    }

    set_cursor(csr_x, csr_y);
 32d:	8b 15 04 00 00 00    	mov    0x4,%edx
			32f: R_386_32	.bss
 333:	a1 00 00 00 00       	mov    0x0,%eax
			334: R_386_32	.bss
 338:	89 54 24 04          	mov    %edx,0x4(%esp)
 33c:	89 04 24             	mov    %eax,(%esp)
 33f:	e8 fc ff ff ff       	call   340 <print_c+0x1df>
			340: R_386_PC32	set_cursor
 344:	eb 01                	jmp    347 <print_c+0x1e6>
            *dest++ = (u8int)BLANK_ATTR;
        }
        break;
    case '\b':
        if ((!csr_x) && (!csr_y))
            return;
 346:	90                   	nop
        else
            scroll_down();
    }

    set_cursor(csr_x, csr_y);
}
 347:	c9                   	leave  
 348:	c3                   	ret    

Disassembly of section .bss:

00000000 <csr_x>:
#include <console/console.h>

static int csr_x, csr_y;

static void scroll_down()
{
   0:	00 00                	add    %al,(%eax)
	...

00000004 <csr_y>:
   4:	00 00                	add    %al,(%eax)
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
   0:	6e                   	outsb  %ds:(%esi),(%dx)
   1:	02 00                	add    (%eax),%al
   3:	00 02                	add    %al,(%edx)
   5:	00 00                	add    %al,(%eax)
			6: R_386_32	.debug_abbrev
    int i;
    u16int *vga_mem = (u16int *)VRAM_START;
   7:	00 00                	add    %al,(%eax)
   9:	00 04 01             	add    %al,(%ecx,%eax,1)
   c:	4a                   	dec    %edx
			c: R_386_32	.debug_str
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);
   d:	01 00                	add    %eax,(%eax)
   f:	00 01                	add    %al,(%ecx)
  11:	8d 00                	lea    (%eax),%eax
			11: R_386_32	.debug_str

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
  13:	00 00                	add    %al,(%eax)
  15:	00 00                	add    %al,(%eax)
			15: R_386_32	.text
  17:	00 00                	add    %al,(%eax)
  19:	49                   	dec    %ecx
			19: R_386_32	.text
  1a:	03 00                	add    (%eax),%eax
  1c:	00 00                	add    %al,(%eax)
			1d: R_386_32	.debug_line
  1e:	00 00                	add    %al,(%eax)
  20:	00 02                	add    %al,(%edx)
  22:	01 06                	add    %eax,(%esi)
  24:	28 01                	sub    %al,(%ecx)
			24: R_386_32	.debug_str
  26:	00 00                	add    %al,(%eax)
  28:	03 04 05 69 6e 74 00 	add    0x746e69(,%eax,1),%eax
  2f:	02 04 07             	add    (%edi,%eax,1),%al
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  32:	15 01 00 00 04       	adc    $0x4000001,%eax
			32: R_386_32	.debug_str
  37:	82                   	(bad)  
			37: R_386_32	.debug_str
  38:	01 00                	add    %eax,(%eax)
  3a:	00 02                	add    %al,(%edx)
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
  3c:	15 41 00 00 00       	adc    $0x41,%eax
  41:	02 02                	add    (%edx),%al
  43:	07                   	pop    %es
  44:	62 00                	bound  %eax,(%eax)
			44: R_386_32	.debug_str
  46:	00 00                	add    %al,(%eax)
  48:	04 fb                	add    $0xfb,%al
			49: R_386_32	.debug_str
  4a:	00 00                	add    %al,(%eax)
  4c:	00 02                	add    %al,(%edx)
  4e:	16                   	push   %ss
  4f:	53                   	push   %ebx
  50:	00 00                	add    %al,(%eax)
  52:	00 02                	add    %al,(%edx)
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  54:	01 08                	add    %ecx,(%eax)
  56:	4f                   	dec    %edi
			56: R_386_32	.debug_str
  57:	00 00                	add    %al,(%eax)
  59:	00 05 01 01 00 00    	add    %al,0x101
			5b: R_386_32	.debug_str
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
    }
}

void set_cursor(int x, int y)
{
  5f:	04 03                	add    $0x3,%al
  61:	14 c7                	adc    $0xc7,%al
  63:	00 00                	add    %al,(%eax)
    u16int position;
    csr_x = x;
  65:	00 06                	add    %al,(%esi)
  67:	22 01                	and    (%ecx),%al
			67: R_386_32	.debug_str
  69:	00 00                	add    %al,(%eax)
  6b:	00 06                	add    %al,(%esi)
    csr_y = y;
  6d:	39 00                	cmp    %eax,(%eax)
			6d: R_386_32	.debug_str
  6f:	00 00                	add    %al,(%eax)
  71:	01 06                	add    %eax,(%esi)
  73:	06                   	push   %es
			73: R_386_32	.debug_str
  74:	00 00                	add    %al,(%eax)

    position = csr_y * CONSOLE_WIDTH + csr_x;
  76:	00 02                	add    %al,(%edx)
  78:	06                   	push   %es
  79:	ca 00 00             	lret   $0x0
			79: R_386_32	.debug_str
  7c:	00 03                	add    %al,(%ebx)
  7e:	07                   	pop    %es
  7f:	52                   	push   %edx
  80:	45                   	inc    %ebp
  81:	44                   	inc    %esp
  82:	00 04 06             	add    %al,(%esi,%eax,1)
  85:	cf                   	iret   
			85: R_386_32	.debug_str
  86:	00 00                	add    %al,(%eax)
  88:	00 05 06 49 00 00    	add    %al,0x4906
			8b: R_386_32	.debug_str
  8e:	00 06                	add    %al,(%esi)
  90:	06                   	push   %es
  91:	0f 01 00             	sgdtl  (%eax)
			91: R_386_32	.debug_str

    outb(0x0f, 0x3d4);
  94:	00 07                	add    %al,(%edi)
  96:	06                   	push   %es
  97:	90                   	nop
			97: R_386_32	.debug_str
  98:	01 00                	add    %eax,(%eax)
  9a:	00 08                	add    %cl,(%eax)
  9c:	06                   	push   %es
  9d:	2d 01 00 00 09       	sub    $0x9000001,%eax
			9d: R_386_32	.debug_str
  a2:	06                   	push   %es
  a3:	38 01                	cmp    %al,(%ecx)
			a3: R_386_32	.debug_str
  a5:	00 00                	add    %al,(%eax)
    outb((u8int)(position & 0xff), 0x3d5);
  a7:	0a 06                	or     (%esi),%al
  a9:	77 01                	ja     ac <.debug_info+0xac>
			a9: R_386_32	.debug_str
  ab:	00 00                	add    %al,(%eax)
  ad:	0b 06                	or     (%esi),%eax
  af:	75 00                	jne    b1 <.debug_info+0xb1>
			af: R_386_32	.debug_str
  b1:	00 00                	add    %al,(%eax)
  b3:	0c 06                	or     $0x6,%al
  b5:	7f 00                	jg     b7 <.debug_info+0xb7>
			b5: R_386_32	.debug_str
  b7:	00 00                	add    %al,(%eax)
  b9:	0d 06 89 01 00       	or     $0x18906,%eax
			bb: R_386_32	.debug_str
    outb(0x0e, 0x3d4);
  be:	00 0e                	add    %cl,(%esi)
  c0:	06                   	push   %es
  c1:	21 00                	and    %eax,(%eax)
			c1: R_386_32	.debug_str
  c3:	00 00                	add    %al,(%eax)
  c5:	0f 00 04 01          	sldt   (%ecx,%eax,1)
			c8: R_386_32	.debug_str
  c9:	01 00                	add    %eax,(%eax)
  cb:	00 03                	add    %al,(%ebx)
  cd:	19 5a 00             	sbb    %ebx,0x0(%edx)
  d0:	00 00                	add    %al,(%eax)
    outb((u8int)((position >> 8) & 0xff), 0x3d5);
  d2:	08 e4                	or     %ah,%ah
			d3: R_386_32	.debug_str
  d4:	00 00                	add    %al,(%eax)
  d6:	00 01                	add    %al,(%ecx)
  d8:	0a 00                	or     (%eax),%al
			d9: R_386_32	.text
  da:	00 00                	add    %al,(%eax)
  dc:	00 5f 00             	add    %bl,0x0(%edi)
			dd: R_386_32	.text
  df:	00 00                	add    %al,(%eax)
  e1:	00 00                	add    %al,(%eax)
			e1: R_386_32	.debug_loc
  e3:	00 00                	add    %al,(%eax)
  e5:	01 13                	add    %edx,(%ebx)
  e7:	01 00                	add    %eax,(%eax)
  e9:	00 09                	add    %cl,(%ecx)
  eb:	69 00 01 0c 28 00    	imul   $0x280c01,(%eax),%eax
}

void get_cursor(int *x, int *y)
{
  f1:	00 00                	add    %al,(%eax)
    *x = csr_x;
  f3:	02 91 6c 0a 5c 01    	add    0x15c0a6c(%ecx),%dl
			f7: R_386_32	.debug_str
  f9:	00 00                	add    %al,(%eax)
  fb:	01 0d 13 01 00 00    	add    %ecx,0x113
    *y = csr_y;
 101:	02 91 68 0a 3e 00    	add    0x3e0a68(%ecx),%dl
			105: R_386_32	.debug_str
 107:	00 00                	add    %al,(%eax)
}
 109:	01 0e                	add    %ecx,(%esi)

void console_init()
{
 10b:	36 00 00             	add    %al,%ss:(%eax)
 10e:	00 02                	add    %al,(%edx)
    clear_screen();
 110:	91                   	xchg   %eax,%ecx
 111:	66                   	data16
 112:	00 0b                	add    %cl,(%ebx)
 114:	04 36                	add    $0x36,%al

    set_cursor(0, 0);
 116:	00 00                	add    %al,(%eax)
 118:	00 0c 01             	add    %cl,(%ecx,%eax,1)
 11b:	f0 00 00             	lock add %al,(%eax)
			11b: R_386_32	.debug_str
 11e:	00 01                	add    %al,(%ecx)
 120:	19 01                	sbb    %eax,(%ecx)
 122:	5f                   	pop    %edi
			122: R_386_32	.text
 123:	00 00                	add    %al,(%eax)
 125:	00 ef                	add    %ch,%bh
			126: R_386_32	.text
 127:	00 00                	add    %al,(%eax)
}
 129:	00 38                	add    %bh,(%eax)
			12a: R_386_32	.debug_loc

void clear_screen()
{
 12b:	00 00                	add    %al,(%eax)
 12d:	00 01                	add    %al,(%ecx)
 12f:	5a                   	pop    %edx
 130:	01 00                	add    %eax,(%eax)
    u16int *vga_mem = (u16int *)VRAM_START;
 132:	00 0d 78 00 01 19    	add    %cl,0x19010078
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);
 138:	28 00                	sub    %al,(%eax)
 13a:	00 00                	add    %al,(%eax)
 13c:	02 91 00 0d 79 00    	add    0x790d00(%ecx),%dl

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
 142:	01 19                	add    %ebx,(%ecx)
 144:	28 00                	sub    %al,(%eax)
    for (; count > 0; count--)
 146:	00 00                	add    %al,(%eax)
        *vga_mem++ = blankchar;
 148:	02 91 04 0a 64 01    	add    0x1640a04(%ecx),%dl
			14c: R_386_32	.debug_str
 14e:	00 00                	add    %al,(%eax)
 150:	01 1b                	add    %ebx,(%ebx)
 152:	36 00 00             	add    %al,%ss:(%eax)
{
    u16int *vga_mem = (u16int *)VRAM_START;
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
    for (; count > 0; count--)
 155:	00 02                	add    %al,(%edx)
 157:	91                   	xchg   %eax,%ecx
 158:	6e                   	outsb  %ds:(%esi),(%dx)
 159:	00 0e                	add    %cl,(%esi)
 15b:	01 2e                	add    %ebp,(%esi)
			15c: R_386_32	.debug_str
 15d:	00 00                	add    %al,(%eax)
        *vga_mem++ = blankchar;
}
 15f:	00 01                	add    %al,(%ecx)

void print_c(char c, CONSOLE_COLOR fg, CONSOLE_COLOR bg)
{
 161:	27                   	daa    
 162:	01 ef                	add    %ebp,%edi
			163: R_386_32	.text
 164:	00 00                	add    %al,(%eax)
 166:	00 0a                	add    %cl,(%edx)
			167: R_386_32	.text
 168:	01 00                	add    %eax,(%eax)
 16a:	00 70 00             	add    %dh,0x0(%eax)
			16b: R_386_32	.debug_loc
    u8int *dest = (u8int *)(VRAM_START + csr_y * VRAM_LINE + csr_x * CONSOLE_CHAR_SIZE);
 16d:	00 00                	add    %al,(%eax)
 16f:	01 8d 01 00 00 0d    	add    %ecx,0xd000001(%ebp)
 175:	78 00                	js     177 <.debug_info+0x177>
 177:	01 27                	add    %esp,(%edi)
 179:	8d 01                	lea    (%ecx),%eax
 17b:	00 00                	add    %al,(%eax)
 17d:	02 91 00 0d 79 00    	add    0x790d00(%ecx),%dl
 183:	01 27                	add    %esp,(%edi)
 185:	8d 01                	lea    (%ecx),%eax
 187:	00 00                	add    %al,(%eax)
 189:	02 91 04 00 0b 04    	add    0x40b0004(%ecx),%dl
    u8int attr = (u8int)(bg << 4 | fg );
 18f:	28 00                	sub    %al,(%eax)
 191:	00 00                	add    %al,(%eax)
 193:	0f 01                	(bad)  
 195:	d7                   	xlat   %ds:(%ebx)
			195: R_386_32	.debug_str
 196:	00 00                	add    %al,(%eax)
 198:	00 01                	add    %al,(%ecx)
 19a:	2d 0a 01 00 00       	sub    $0x10a,%eax
			19b: R_386_32	.text

    switch (c)
 19f:	2b 01                	sub    (%ecx),%eax
			19f: R_386_32	.text
 1a1:	00 00                	add    %al,(%eax)
 1a3:	a8 00                	test   $0x0,%al
			1a3: R_386_32	.debug_loc
 1a5:	00 00                	add    %al,(%eax)
 1a7:	01 10                	add    %edx,(%eax)
 1a9:	01 14 00             	add    %edx,(%eax,%eax,1)
			1aa: R_386_32	.debug_str
 1ac:	00 00                	add    %al,(%eax)
 1ae:	01 34 2b             	add    %esi,(%ebx,%ebp,1)
			1b0: R_386_32	.text
 1b1:	01 00                	add    %eax,(%eax)
 1b3:	00 61 01             	add    %ah,0x1(%ecx)
			1b4: R_386_32	.text
 1b6:	00 00                	add    %al,(%eax)
 1b8:	e0 00                	loopne 1ba <.debug_info+0x1ba>
			1b8: R_386_32	.debug_loc
 1ba:	00 00                	add    %al,(%eax)
 1bc:	01 ec                	add    %ebp,%esp
 1be:	01 00                	add    %eax,(%eax)
 1c0:	00 0a                	add    %cl,(%edx)
 1c2:	5c                   	pop    %esp
			1c2: R_386_32	.debug_str
 1c3:	01 00                	add    %eax,(%eax)
 1c5:	00 01                	add    %al,(%ecx)
 1c7:	36 13 01             	adc    %ss:(%ecx),%eax
    {
    case '\r':
        csr_x = 0;
 1ca:	00 00                	add    %al,(%eax)
 1cc:	02 91 74 0a 6d 01    	add    0x16d0a74(%ecx),%dl
			1d0: R_386_32	.debug_str
 1d2:	00 00                	add    %al,(%eax)
        break;
 1d4:	01 37                	add    %esi,(%edi)
 1d6:	36 00 00             	add    %al,%ss:(%eax)
    case '\n':
        for (; csr_x < CONSOLE_WIDTH; ++csr_x)
        {
            *dest++ = BLANK_CHAR;
 1d9:	00 02                	add    %al,(%edx)
 1db:	91                   	xchg   %eax,%ecx
 1dc:	6e                   	outsb  %ds:(%esi),(%dx)
 1dd:	0a 56 01             	or     0x1(%esi),%dl
			1de: R_386_32	.debug_str
 1e0:	00 00                	add    %al,(%eax)
            *dest++ = attr;
 1e2:	01 39                	add    %edi,(%ecx)
 1e4:	28 00                	sub    %al,(%eax)
 1e6:	00 00                	add    %al,(%eax)
 1e8:	02 91 70 00 0c 01    	add    0x10c0070(%ecx),%dl
 1ee:	0c 00                	or     $0x0,%al
			1ee: R_386_32	.debug_str
    {
    case '\r':
        csr_x = 0;
        break;
    case '\n':
        for (; csr_x < CONSOLE_WIDTH; ++csr_x)
 1f0:	00 00                	add    %al,(%eax)
 1f2:	01 3e                	add    %edi,(%esi)
 1f4:	01 61 01             	add    %esp,0x1(%ecx)
			1f5: R_386_32	.text
 1f7:	00 00                	add    %al,(%eax)
 1f9:	49                   	dec    %ecx
			1f9: R_386_32	.text
 1fa:	03 00                	add    (%eax),%eax
 1fc:	00 18                	add    %bl,(%eax)
			1fd: R_386_32	.debug_loc
 1fe:	01 00                	add    %eax,(%eax)
 200:	00 01                	add    %al,(%ecx)
 202:	49                   	dec    %ecx
 203:	02 00                	add    (%eax),%al
 205:	00 0d 63 00 01 3e    	add    %cl,0x3e010063
        {
            *dest++ = BLANK_CHAR;
            *dest++ = attr;
        }
        break;
 20b:	21 00                	and    %eax,(%eax)
 20d:	00 00                	add    %al,(%eax)
    case '\t':
        c = csr_x + TAB_WIDTH - (csr_x % TAB_WIDTH);
 20f:	02 91 5c 0d 66 67    	add    0x67660d5c(%ecx),%dl
 215:	00 01                	add    %al,(%ecx)
 217:	3e c7 00 00 00 02 91 	movl   $0x91020000,%ds:(%eax)
 21e:	04 0d                	add    $0xd,%al
 220:	62 67 00             	bound  %esp,0x0(%edi)
 223:	01 3e                	add    %edi,(%esi)
 225:	c7 00 00 00 02 91    	movl   $0x91020000,(%eax)
 22b:	08 0a                	or     %cl,(%edx)
 22d:	44                   	inc    %esp
			22d: R_386_32	.debug_str
 22e:	00 00                	add    %al,(%eax)
 230:	00 01                	add    %al,(%ecx)
 232:	40                   	inc    %eax
 233:	49                   	dec    %ecx
 234:	02 00                	add    (%eax),%al
        c = c < CONSOLE_WIDTH ? c : CONSOLE_WIDTH;
 236:	00 02                	add    %al,(%edx)
 238:	91                   	xchg   %eax,%ecx
 239:	6c                   	insb   (%dx),%es:(%edi)
 23a:	0a 5d 00             	or     0x0(%ebp),%bl
			23b: R_386_32	.debug_str
 23d:	00 00                	add    %al,(%eax)
 23f:	01 41 48             	add    %eax,0x48(%ecx)
 242:	00 00                	add    %al,(%eax)
 244:	00 02                	add    %al,(%edx)
        for (; csr_x < c; ++csr_x)
 246:	91                   	xchg   %eax,%ecx
        {
            *dest++ = (u8int)BLANK_CHAR;
 247:	6b 00 0b             	imul   $0xb,(%eax),%eax
 24a:	04 48                	add    $0x48,%al
 24c:	00 00                	add    %al,(%eax)
 24e:	00 0a                	add    %cl,(%edx)
 250:	00 00                	add    %al,(%eax)
			250: R_386_32	.debug_str
            *dest++ = (u8int)BLANK_ATTR;
 252:	00 00                	add    %al,(%eax)
 254:	01 08                	add    %ecx,(%eax)
 256:	28 00                	sub    %al,(%eax)
 258:	00 00                	add    %al,(%eax)
 25a:	05 03 00 00 00       	add    $0x3,%eax
			25c: R_386_32	.bss
        }
        break;
    case '\t':
        c = csr_x + TAB_WIDTH - (csr_x % TAB_WIDTH);
        c = c < CONSOLE_WIDTH ? c : CONSOLE_WIDTH;
        for (; csr_x < c; ++csr_x)
 25f:	00 0a                	add    %cl,(%edx)
 261:	44                   	inc    %esp
			261: R_386_32	.debug_str
 262:	01 00                	add    %eax,(%eax)
 264:	00 01                	add    %al,(%ecx)
 266:	08 28                	or     %ch,(%eax)
 268:	00 00                	add    %al,(%eax)
 26a:	00 05 03 04 00 00    	add    %al,0x403
			26d: R_386_32	.bss
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
#include <console/console.h>

static int csr_x, csr_y;

static void scroll_down()
{
   0:	01 11                	add    %edx,(%ecx)
   2:	01 25 0e 13 0b 03    	add    %esp,0x30b130e
    int i;
    u16int *vga_mem = (u16int *)VRAM_START;
   8:	0e                   	push   %cs
   9:	11 01                	adc    %eax,(%ecx)
   b:	12 01                	adc    (%ecx),%al
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);
   d:	10 06                	adc    %al,(%esi)
   f:	00 00                	add    %al,(%eax)
  11:	02 24 00             	add    (%eax,%eax,1),%ah

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
  14:	0b 0b                	or     (%ebx),%ecx
  16:	3e 0b 03             	or     %ds:(%ebx),%eax
  19:	0e                   	push   %cs
  1a:	00 00                	add    %al,(%eax)
  1c:	03 24 00             	add    (%eax,%eax,1),%esp
  1f:	0b 0b                	or     (%ebx),%ecx
  21:	3e 0b 03             	or     %ds:(%ebx),%eax
  24:	08 00                	or     %al,(%eax)
  26:	00 04 16             	add    %al,(%esi,%edx,1)
  29:	00 03                	add    %al,(%ebx)
  2b:	0e                   	push   %cs
  2c:	3a 0b                	cmp    (%ebx),%cl
  2e:	3b 0b                	cmp    (%ebx),%ecx
  30:	49                   	dec    %ecx
  31:	13 00                	adc    (%eax),%eax
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  33:	00 05 04 01 03 0e    	add    %al,0xe030104
  39:	0b 0b                	or     (%ebx),%ecx
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
  3b:	3a 0b                	cmp    (%ebx),%cl
  3d:	3b 0b                	cmp    (%ebx),%ecx
  3f:	01 13                	add    %edx,(%ebx)
  41:	00 00                	add    %al,(%eax)
  43:	06                   	push   %es
  44:	28 00                	sub    %al,(%eax)
  46:	03 0e                	add    (%esi),%ecx
  48:	1c 0d                	sbb    $0xd,%al
  4a:	00 00                	add    %al,(%eax)
  4c:	07                   	pop    %es
  4d:	28 00                	sub    %al,(%eax)
  4f:	03 08                	add    (%eax),%ecx
  51:	1c 0d                	sbb    $0xd,%al
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  53:	00 00                	add    %al,(%eax)
  55:	08 2e                	or     %ch,(%esi)
  57:	01 03                	add    %eax,(%ebx)
  59:	0e                   	push   %cs
  5a:	3a 0b                	cmp    (%ebx),%cl
  5c:	3b 0b                	cmp    (%ebx),%ecx
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
    }
}
  5e:	11 01                	adc    %eax,(%ecx)

void set_cursor(int x, int y)
{
  60:	12 01                	adc    (%ecx),%al
  62:	40                   	inc    %eax
  63:	06                   	push   %es
  64:	96                   	xchg   %eax,%esi
    u16int position;
    csr_x = x;
  65:	42                   	inc    %edx
  66:	0c 01                	or     $0x1,%al
  68:	13 00                	adc    (%eax),%eax
  6a:	00 09                	add    %cl,(%ecx)
  6c:	34 00                	xor    $0x0,%al
    csr_y = y;
  6e:	03 08                	add    (%eax),%ecx
  70:	3a 0b                	cmp    (%ebx),%cl
  72:	3b 0b                	cmp    (%ebx),%ecx
  74:	49                   	dec    %ecx

    position = csr_y * CONSOLE_WIDTH + csr_x;
  75:	13 02                	adc    (%edx),%eax
  77:	0a 00                	or     (%eax),%al
  79:	00 0a                	add    %cl,(%edx)
  7b:	34 00                	xor    $0x0,%al
  7d:	03 0e                	add    (%esi),%ecx
  7f:	3a 0b                	cmp    (%ebx),%cl
  81:	3b 0b                	cmp    (%ebx),%ecx
  83:	49                   	dec    %ecx
  84:	13 02                	adc    (%edx),%eax
  86:	0a 00                	or     (%eax),%al
  88:	00 0b                	add    %cl,(%ebx)
  8a:	0f 00 0b             	str    (%ebx)
  8d:	0b 49 13             	or     0x13(%ecx),%ecx
  90:	00 00                	add    %al,(%eax)
  92:	0c 2e                	or     $0x2e,%al

    outb(0x0f, 0x3d4);
  94:	01 3f                	add    %edi,(%edi)
  96:	0c 03                	or     $0x3,%al
  98:	0e                   	push   %cs
  99:	3a 0b                	cmp    (%ebx),%cl
  9b:	3b 0b                	cmp    (%ebx),%ecx
  9d:	27                   	daa    
  9e:	0c 11                	or     $0x11,%al
  a0:	01 12                	add    %edx,(%edx)
  a2:	01 40 06             	add    %eax,0x6(%eax)
  a5:	96                   	xchg   %eax,%esi
  a6:	42                   	inc    %edx
    outb((u8int)(position & 0xff), 0x3d5);
  a7:	0c 01                	or     $0x1,%al
  a9:	13 00                	adc    (%eax),%eax
  ab:	00 0d 05 00 03 08    	add    %cl,0x8030005
  b1:	3a 0b                	cmp    (%ebx),%cl
  b3:	3b 0b                	cmp    (%ebx),%ecx
  b5:	49                   	dec    %ecx
  b6:	13 02                	adc    (%edx),%eax
  b8:	0a 00                	or     (%eax),%al
  ba:	00 0e                	add    %cl,(%esi)
  bc:	2e 01 3f             	add    %edi,%cs:(%edi)
    outb(0x0e, 0x3d4);
  bf:	0c 03                	or     $0x3,%al
  c1:	0e                   	push   %cs
  c2:	3a 0b                	cmp    (%ebx),%cl
  c4:	3b 0b                	cmp    (%ebx),%ecx
  c6:	27                   	daa    
  c7:	0c 11                	or     $0x11,%al
  c9:	01 12                	add    %edx,(%edx)
  cb:	01 40 06             	add    %eax,0x6(%eax)
  ce:	97                   	xchg   %eax,%edi
  cf:	42                   	inc    %edx
  d0:	0c 01                	or     $0x1,%al
    outb((u8int)((position >> 8) & 0xff), 0x3d5);
  d2:	13 00                	adc    (%eax),%eax
  d4:	00 0f                	add    %cl,(%edi)
  d6:	2e 00 3f             	add    %bh,%cs:(%edi)
  d9:	0c 03                	or     $0x3,%al
  db:	0e                   	push   %cs
  dc:	3a 0b                	cmp    (%ebx),%cl
  de:	3b 0b                	cmp    (%ebx),%ecx
  e0:	11 01                	adc    %eax,(%ecx)
  e2:	12 01                	adc    (%ecx),%al
  e4:	40                   	inc    %eax
  e5:	06                   	push   %es
  e6:	96                   	xchg   %eax,%esi
  e7:	42                   	inc    %edx
  e8:	0c 00                	or     $0x0,%al
  ea:	00 10                	add    %dl,(%eax)
  ec:	2e 01 3f             	add    %edi,%cs:(%edi)
}

void get_cursor(int *x, int *y)
{
  ef:	0c 03                	or     $0x3,%al
  f1:	0e                   	push   %cs
    *x = csr_x;
  f2:	3a 0b                	cmp    (%ebx),%cl
  f4:	3b 0b                	cmp    (%ebx),%ecx
  f6:	11 01                	adc    %eax,(%ecx)
  f8:	12 01                	adc    (%ecx),%al
  fa:	40                   	inc    %eax
  fb:	06                   	push   %es
  fc:	97                   	xchg   %eax,%edi
    *y = csr_y;
  fd:	42                   	inc    %edx
  fe:	0c 01                	or     $0x1,%al
 100:	13 00                	adc    (%eax),%eax
	...

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
#include <console/console.h>

static int csr_x, csr_y;

static void scroll_down()
{
   0:	00 00                	add    %al,(%eax)
   2:	00 00                	add    %al,(%eax)
   4:	01 00                	add    %eax,(%eax)
    int i;
    u16int *vga_mem = (u16int *)VRAM_START;
   6:	00 00                	add    %al,(%eax)
   8:	02 00                	add    (%eax),%al
   a:	74 04                	je     10 <.debug_loc+0x10>
   c:	01 00                	add    %eax,(%eax)
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);
   e:	00 00                	add    %al,(%eax)
  10:	03 00                	add    (%eax),%eax
  12:	00 00                	add    %al,(%eax)

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
  14:	02 00                	add    (%eax),%al
  16:	74 08                	je     20 <.debug_loc+0x20>
  18:	03 00                	add    (%eax),%eax
  1a:	00 00                	add    %al,(%eax)
  1c:	5e                   	pop    %esi
  1d:	00 00                	add    %al,(%eax)
  1f:	00 02                	add    %al,(%edx)
  21:	00 75 08             	add    %dh,0x8(%ebp)
  24:	5e                   	pop    %esi
  25:	00 00                	add    %al,(%eax)
  27:	00 5f 00             	add    %bl,0x0(%edi)
  2a:	00 00                	add    %al,(%eax)
  2c:	02 00                	add    (%eax),%al
  2e:	74 04                	je     34 <.debug_loc+0x34>
	...
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  38:	5f                   	pop    %edi
  39:	00 00                	add    %al,(%eax)
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
  3b:	00 60 00             	add    %ah,0x0(%eax)
  3e:	00 00                	add    %al,(%eax)
  40:	02 00                	add    (%eax),%al
  42:	74 04                	je     48 <.debug_loc+0x48>
  44:	60                   	pusha  
  45:	00 00                	add    %al,(%eax)
  47:	00 62 00             	add    %ah,0x0(%edx)
  4a:	00 00                	add    %al,(%eax)
  4c:	02 00                	add    (%eax),%al
  4e:	74 08                	je     58 <.debug_loc+0x58>
  50:	62 00                	bound  %eax,(%eax)
  52:	00 00                	add    %al,(%eax)
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  54:	ee                   	out    %al,(%dx)
  55:	00 00                	add    %al,(%eax)
  57:	00 02                	add    %al,(%edx)
  59:	00 75 08             	add    %dh,0x8(%ebp)
  5c:	ee                   	out    %al,(%dx)
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
    }
}
  5d:	00 00                	add    %al,(%eax)

void set_cursor(int x, int y)
{
  5f:	00 ef                	add    %ch,%bh
  61:	00 00                	add    %al,(%eax)
  63:	00 02                	add    %al,(%edx)
    u16int position;
    csr_x = x;
  65:	00 74 04 00          	add    %dh,0x0(%esp,%eax,1)
  69:	00 00                	add    %al,(%eax)
  6b:	00 00                	add    %al,(%eax)
    csr_y = y;
  6d:	00 00                	add    %al,(%eax)
  6f:	00 ef                	add    %ch,%bh
  71:	00 00                	add    %al,(%eax)
  73:	00 f0                	add    %dh,%al

    position = csr_y * CONSOLE_WIDTH + csr_x;
  75:	00 00                	add    %al,(%eax)
  77:	00 02                	add    %al,(%edx)
  79:	00 74 04 f0          	add    %dh,-0x10(%esp,%eax,1)
  7d:	00 00                	add    %al,(%eax)
  7f:	00 f2                	add    %dh,%dl
  81:	00 00                	add    %al,(%eax)
  83:	00 02                	add    %al,(%edx)
  85:	00 74 08 f2          	add    %dh,-0xe(%eax,%ecx,1)
  89:	00 00                	add    %al,(%eax)
  8b:	00 09                	add    %cl,(%ecx)
  8d:	01 00                	add    %eax,(%eax)
  8f:	00 02                	add    %al,(%edx)
  91:	00 75 08             	add    %dh,0x8(%ebp)

    outb(0x0f, 0x3d4);
  94:	09 01                	or     %eax,(%ecx)
  96:	00 00                	add    %al,(%eax)
  98:	0a 01                	or     (%ecx),%al
  9a:	00 00                	add    %al,(%eax)
  9c:	02 00                	add    (%eax),%al
  9e:	74 04                	je     a4 <.debug_loc+0xa4>
	...
    outb((u8int)(position & 0xff), 0x3d5);
  a8:	0a 01                	or     (%ecx),%al
  aa:	00 00                	add    %al,(%eax)
  ac:	0b 01                	or     (%ecx),%eax
  ae:	00 00                	add    %al,(%eax)
  b0:	02 00                	add    (%eax),%al
  b2:	74 04                	je     b8 <.debug_loc+0xb8>
  b4:	0b 01                	or     (%ecx),%eax
  b6:	00 00                	add    %al,(%eax)
  b8:	0d 01 00 00 02       	or     $0x2000001,%eax
  bd:	00 74 08 0d          	add    %dh,0xd(%eax,%ecx,1)
    outb(0x0e, 0x3d4);
  c1:	01 00                	add    %eax,(%eax)
  c3:	00 2a                	add    %ch,(%edx)
  c5:	01 00                	add    %eax,(%eax)
  c7:	00 02                	add    %al,(%edx)
  c9:	00 75 08             	add    %dh,0x8(%ebp)
  cc:	2a 01                	sub    (%ecx),%al
  ce:	00 00                	add    %al,(%eax)
  d0:	2b 01                	sub    (%ecx),%eax
    outb((u8int)((position >> 8) & 0xff), 0x3d5);
  d2:	00 00                	add    %al,(%eax)
  d4:	02 00                	add    (%eax),%al
  d6:	74 04                	je     dc <.debug_loc+0xdc>
	...
  e0:	2b 01                	sub    (%ecx),%eax
  e2:	00 00                	add    %al,(%eax)
  e4:	2c 01                	sub    $0x1,%al
  e6:	00 00                	add    %al,(%eax)
  e8:	02 00                	add    (%eax),%al
  ea:	74 04                	je     f0 <.debug_loc+0xf0>
  ec:	2c 01                	sub    $0x1,%al
}
  ee:	00 00                	add    %al,(%eax)

void get_cursor(int *x, int *y)
{
  f0:	2e 01 00             	add    %eax,%cs:(%eax)
    *x = csr_x;
  f3:	00 02                	add    %al,(%edx)
  f5:	00 74 08 2e          	add    %dh,0x2e(%eax,%ecx,1)
  f9:	01 00                	add    %eax,(%eax)
  fb:	00 60 01             	add    %ah,0x1(%eax)
    *y = csr_y;
  fe:	00 00                	add    %al,(%eax)
 100:	02 00                	add    (%eax),%al
 102:	75 08                	jne    10c <.debug_loc+0x10c>
 104:	60                   	pusha  
 105:	01 00                	add    %eax,(%eax)
 107:	00 61 01             	add    %ah,0x1(%ecx)
}

void console_init()
{
 10a:	00 00                	add    %al,(%eax)
 10c:	02 00                	add    (%eax),%al
 10e:	74 04                	je     114 <.debug_loc+0x114>
	...
    clear_screen();

    set_cursor(0, 0);
 118:	61                   	popa   
 119:	01 00                	add    %eax,(%eax)
 11b:	00 62 01             	add    %ah,0x1(%edx)
 11e:	00 00                	add    %al,(%eax)
 120:	02 00                	add    (%eax),%al
 122:	74 04                	je     128 <.debug_loc+0x128>
 124:	62 01                	bound  %eax,(%ecx)
 126:	00 00                	add    %al,(%eax)
 128:	64 01 00             	add    %eax,%fs:(%eax)
}

void clear_screen()
{
 12b:	00 02                	add    %al,(%edx)
 12d:	00 74 08 64          	add    %dh,0x64(%eax,%ecx,1)
    u16int *vga_mem = (u16int *)VRAM_START;
 131:	01 00                	add    %eax,(%eax)
 133:	00 48 03             	add    %cl,0x3(%eax)
 136:	00 00                	add    %al,(%eax)
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);
 138:	02 00                	add    (%eax),%al
 13a:	75 08                	jne    144 <.debug_loc+0x144>
 13c:	48                   	dec    %eax
 13d:	03 00                	add    (%eax),%eax

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
 13f:	00 49 03             	add    %cl,0x3(%ecx)
 142:	00 00                	add    %al,(%eax)
 144:	02 00                	add    (%eax),%al
    for (; count > 0; count--)
 146:	74 04                	je     14c <.debug_loc+0x14c>
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
#include <console/console.h>

static int csr_x, csr_y;

static void scroll_down()
{
   0:	1c 00                	sbb    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
    int i;
    u16int *vga_mem = (u16int *)VRAM_START;
   6:	00 00                	add    %al,(%eax)
			6: R_386_32	.debug_info
   8:	00 00                	add    %al,(%eax)
   a:	04 00                	add    $0x0,%al
	...
			10: R_386_32	.text
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
  14:	49                   	dec    %ecx
  15:	03 00                	add    (%eax),%eax
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
#include <console/console.h>

static int csr_x, csr_y;

static void scroll_down()
{
   0:	89 01                	mov    %eax,(%ecx)
   2:	00 00                	add    %al,(%eax)
   4:	02 00                	add    (%eax),%al
    int i;
    u16int *vga_mem = (u16int *)VRAM_START;
   6:	d0 00                	rolb   (%eax)
   8:	00 00                	add    %al,(%eax)
   a:	01 01                	add    %eax,(%ecx)
   c:	fb                   	sti    
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);
   d:	0e                   	push   %cs
   e:	0d 00 01 01 01       	or     $0x1010100,%eax

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
  13:	01 00                	add    %eax,(%eax)
  15:	00 00                	add    %al,(%eax)
  17:	01 00                	add    %eax,(%eax)
  19:	00 01                	add    %al,(%ecx)
  1b:	2f                   	das    
  1c:	68 6f 6d 65 2f       	push   $0x2f656d6f
  21:	62 6c 65 73          	bound  %ebp,0x73(%ebp,%eiz,2)
  25:	73 65                	jae    8c <.debug_line+0x8c>
  27:	64                   	fs
  28:	2f                   	das    
  29:	50                   	push   %eax
  2a:	72 6f                	jb     9b <.debug_line+0x9b>
  2c:	67 72 61             	addr16 jb 90 <.debug_line+0x90>
  2f:	6d                   	insl   (%dx),%es:(%edi)
  30:	6f                   	outsl  %ds:(%esi),(%dx)
  31:	77 61                	ja     94 <.debug_line+0x94>
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  33:	6e                   	outsb  %ds:(%esi),(%dx)
  34:	69 65 2f 62 6c 65 73 	imul   $0x73656c62,0x2f(%ebp),%esp
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
  3b:	73 4f                	jae    8c <.debug_line+0x8c>
  3d:	53                   	push   %ebx
  3e:	2f                   	das    
  3f:	65                   	gs
  40:	78 2f                	js     71 <.debug_line+0x71>
  42:	73 72                	jae    b6 <.debug_line+0xb6>
  44:	63 2f                	arpl   %bp,(%edi)
  46:	63 6f 6e             	arpl   %bp,0x6e(%edi)
  49:	73 6f                	jae    ba <.debug_line+0xba>
  4b:	6c                   	insb   (%dx),%es:(%edi)
  4c:	65 00 2f             	add    %ch,%gs:(%edi)
  4f:	68 6f 6d 65 2f       	push   $0x2f656d6f
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  54:	62 6c 65 73          	bound  %ebp,0x73(%ebp,%eiz,2)
  58:	73 65                	jae    bf <.debug_line+0xbf>
  5a:	64                   	fs
  5b:	2f                   	das    
  5c:	50                   	push   %eax
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
    }
}
  5d:	72 6f                	jb     ce <.debug_line+0xce>

void set_cursor(int x, int y)
{
  5f:	67 72 61             	addr16 jb c3 <.debug_line+0xc3>
  62:	6d                   	insl   (%dx),%es:(%edi)
  63:	6f                   	outsl  %ds:(%esi),(%dx)
  64:	77 61                	ja     c7 <.debug_line+0xc7>
    u16int position;
    csr_x = x;
  66:	6e                   	outsb  %ds:(%esi),(%dx)
  67:	69 65 2f 62 6c 65 73 	imul   $0x73656c62,0x2f(%ebp),%esp
    csr_y = y;
  6e:	73 4f                	jae    bf <.debug_line+0xbf>
  70:	53                   	push   %ebx
  71:	2f                   	das    
  72:	65                   	gs
  73:	78 2f                	js     a4 <.debug_line+0xa4>

    position = csr_y * CONSOLE_WIDTH + csr_x;
  75:	69 6e 63 2f 63 6f 6d 	imul   $0x6d6f632f,0x63(%esi),%ebp
  7c:	6d                   	insl   (%dx),%es:(%edi)
  7d:	6f                   	outsl  %ds:(%esi),(%dx)
  7e:	6e                   	outsb  %ds:(%esi),(%dx)
  7f:	00 2f                	add    %ch,(%edi)
  81:	68 6f 6d 65 2f       	push   $0x2f656d6f
  86:	62 6c 65 73          	bound  %ebp,0x73(%ebp,%eiz,2)
  8a:	73 65                	jae    f1 <.debug_line+0xf1>
  8c:	64                   	fs
  8d:	2f                   	das    
  8e:	50                   	push   %eax
  8f:	72 6f                	jb     100 <.debug_line+0x100>
  91:	67 72 61             	addr16 jb f5 <.debug_line+0xf5>

    outb(0x0f, 0x3d4);
  94:	6d                   	insl   (%dx),%es:(%edi)
  95:	6f                   	outsl  %ds:(%esi),(%dx)
  96:	77 61                	ja     f9 <.debug_line+0xf9>
  98:	6e                   	outsb  %ds:(%esi),(%dx)
  99:	69 65 2f 62 6c 65 73 	imul   $0x73656c62,0x2f(%ebp),%esp
  a0:	73 4f                	jae    f1 <.debug_line+0xf1>
  a2:	53                   	push   %ebx
  a3:	2f                   	das    
  a4:	65                   	gs
  a5:	78 2f                	js     d6 <.debug_line+0xd6>
    outb((u8int)(position & 0xff), 0x3d5);
  a7:	69 6e 63 2f 63 6f 6e 	imul   $0x6e6f632f,0x63(%esi),%ebp
  ae:	73 6f                	jae    11f <.debug_line+0x11f>
  b0:	6c                   	insb   (%dx),%es:(%edi)
  b1:	65 00 00             	add    %al,%gs:(%eax)
  b4:	63 6f 6e             	arpl   %bp,0x6e(%edi)
  b7:	73 6f                	jae    128 <.debug_line+0x128>
  b9:	6c                   	insb   (%dx),%es:(%edi)
  ba:	65 2e 63 00          	gs arpl %ax,%cs:%gs:(%eax)
    outb(0x0e, 0x3d4);
  be:	01 00                	add    %eax,(%eax)
  c0:	00 74 79 70          	add    %dh,0x70(%ecx,%edi,2)
  c4:	65                   	gs
  c5:	73 2e                	jae    f5 <.debug_line+0xf5>
  c7:	68 00 02 00 00       	push   $0x200
  cc:	63 6f 6e             	arpl   %bp,0x6e(%edi)
  cf:	73 6f                	jae    140 <.debug_line+0x140>
  d1:	6c                   	insb   (%dx),%es:(%edi)
    outb((u8int)((position >> 8) & 0xff), 0x3d5);
  d2:	65                   	gs
  d3:	2e                   	cs
  d4:	68 00 03 00 00       	push   $0x300
  d9:	00 00                	add    %al,(%eax)
  db:	05 02 00 00 00       	add    $0x2,%eax
			dd: R_386_32	.text
  e0:	00 03                	add    %al,(%ebx)
  e2:	0a 01                	or     (%ecx),%al
  e4:	68 75 68 08 d9       	push   $0xd9086875
  e9:	00 02                	add    %al,(%edx)
  eb:	04 02                	add    $0x2,%al
}
  ed:	92                   	xchg   %eax,%edx
  ee:	00 02                	add    %al,(%edx)

void get_cursor(int *x, int *y)
{
  f0:	04 02                	add    $0x2,%al
    *x = csr_x;
  f2:	08 72 00             	or     %dh,0x0(%edx)
  f5:	02 04 01             	add    (%ecx,%eax,1),%al
  f8:	06                   	push   %es
  f9:	4a                   	dec    %edx
  fa:	06                   	push   %es
  fb:	6a 31                	push   $0x31
    *y = csr_y;
  fd:	68 83 84 08 ca       	push   $0xca088483
 102:	08 3d 08 67 08 3d    	or     %bh,0x3d086708
}
 108:	08 9f 31 3d ad ad    	or     %bl,-0x5252c2cf(%edi)

void console_init()
{
 10e:	31 67 5a             	xor    %esp,0x5a(%edi)
    clear_screen();
 111:	08 3d 31 67 75 68    	or     %bh,0x68756731

    set_cursor(0, 0);
 117:	75 00                	jne    119 <.debug_line+0x119>
 119:	02 04 02             	add    (%edx,%eax,1),%al
 11c:	2f                   	das    
 11d:	00 02                	add    %al,(%edx)
 11f:	04 02                	add    $0x2,%al
 121:	d5 00                	aad    $0x0
 123:	02 04 01             	add    (%ecx,%eax,1),%al
 126:	06                   	push   %es
 127:	4a                   	dec    %edx
 128:	06                   	push   %es
}
 129:	68 31 bb 02 22       	push   $0x2202bb31

void clear_screen()
{
 12e:	13 f4                	adc    %esp,%esi
 130:	02 2a                	add    (%edx),%ch
    u16int *vga_mem = (u16int *)VRAM_START;
 132:	15 9f 00 02 04       	adc    $0x402009f,%eax
 137:	02 5c 00 02          	add    0x2(%eax,%eax,1),%bl
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);
 13b:	04 02                	add    $0x2,%al
 13d:	9f                   	lahf   

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
 13e:	00 02                	add    %al,(%edx)
 140:	04 02                	add    $0x2,%al
 142:	c5 06                	lds    (%esi),%eax
 144:	e4 00                	in     $0x0,%al
    for (; count > 0; count--)
 146:	02 04 01             	add    (%ecx,%eax,1),%al
        *vga_mem++ = blankchar;
 149:	20 06                	and    %al,(%esi)
 14b:	a3 5a 02 27 13       	mov    %eax,0x1327025a
 150:	f3 00 02             	repz add %al,(%edx)
 153:	04 02                	add    $0x2,%al
{
    u16int *vga_mem = (u16int *)VRAM_START;
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
    for (; count > 0; count--)
 155:	30 00                	xor    %al,(%eax)
 157:	02 04 02             	add    (%edx,%eax,1),%al
 15a:	9f                   	lahf   
 15b:	00 02                	add    %al,(%edx)
 15d:	04 02                	add    $0x2,%al
        *vga_mem++ = blankchar;
}
 15f:	9b                   	fwait
 160:	00 02                	add    %al,(%edx)

void print_c(char c, CONSOLE_COLOR fg, CONSOLE_COLOR bg)
{
 162:	04 01                	add    $0x1,%al
 164:	06                   	push   %es
 165:	c8 06 cd 5a          	enter  $0xcd06,$0x5a
 169:	00 02                	add    %al,(%edx)
 16b:	04 01                	add    $0x1,%al
    u8int *dest = (u8int *)(VRAM_START + csr_y * VRAM_LINE + csr_x * CONSOLE_CHAR_SIZE);
 16d:	06                   	push   %es
 16e:	90                   	nop
 16f:	06                   	push   %es
 170:	cb                   	lret   
 171:	92                   	xchg   %eax,%edx
 172:	9f                   	lahf   
 173:	e6 ca                	out    %al,$0xca
 175:	91                   	xchg   %eax,%ecx
 176:	91                   	xchg   %eax,%ecx
 177:	30 c9                	xor    %cl,%cl
 179:	c9                   	leave  
 17a:	c9                   	leave  
 17b:	23 a0 9f 9f e6 5b    	and    0x5be69f9f(%eax),%esp
 181:	03 64 08 82          	add    -0x7e(%eax,%ecx,1),%esp
 185:	03 1d 20 02 02 00    	add    0x20220,%ebx
 18b:	01 01                	add    %eax,(%ecx)

Disassembly of section .debug_str:

00000000 <.debug_str>:
#include <console/console.h>

static int csr_x, csr_y;

static void scroll_down()
{
   0:	63 73 72             	arpl   %si,0x72(%ebx)
   3:	5f                   	pop    %edi
   4:	78 00                	js     6 <.debug_str+0x6>
    int i;
    u16int *vga_mem = (u16int *)VRAM_START;
   6:	47                   	inc    %edi
   7:	52                   	push   %edx
   8:	45                   	inc    %ebp
   9:	45                   	inc    %ebp
   a:	4e                   	dec    %esi
   b:	00 70 72             	add    %dh,0x72(%eax)
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);
   e:	69 6e 74 5f 63 00 63 	imul   $0x6300635f,0x74(%esi),%ebp

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
  15:	6c                   	insb   (%dx),%es:(%edi)
  16:	65                   	gs
  17:	61                   	popa   
  18:	72 5f                	jb     79 <.debug_str+0x79>
  1a:	73 63                	jae    7f <.debug_str+0x7f>
  1c:	72 65                	jb     83 <.debug_str+0x83>
  1e:	65 6e                	outsb  %gs:(%esi),(%dx)
  20:	00 42 52             	add    %al,0x52(%edx)
  23:	49                   	dec    %ecx
  24:	47                   	inc    %edi
  25:	48                   	dec    %eax
  26:	54                   	push   %esp
  27:	5f                   	pop    %edi
  28:	57                   	push   %edi
  29:	48                   	dec    %eax
  2a:	49                   	dec    %ecx
  2b:	54                   	push   %esp
  2c:	45                   	inc    %ebp
  2d:	00 67 65             	add    %ah,0x65(%edi)
  30:	74 5f                	je     91 <.debug_str+0x91>
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  32:	63 75 72             	arpl   %si,0x72(%ebp)
  35:	73 6f                	jae    a6 <.debug_str+0xa6>
  37:	72 00                	jb     39 <.debug_str+0x39>
  39:	42                   	inc    %edx
  3a:	4c                   	dec    %esp
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
  3b:	55                   	push   %ebp
  3c:	45                   	inc    %ebp
  3d:	00 62 6c             	add    %ah,0x6c(%edx)
  40:	61                   	popa   
  41:	6e                   	outsb  %ds:(%esi),(%dx)
  42:	6b 00 64             	imul   $0x64,(%eax),%eax
  45:	65                   	gs
  46:	73 74                	jae    bc <.debug_str+0xbc>
  48:	00 42 52             	add    %al,0x52(%edx)
  4b:	4f                   	dec    %edi
  4c:	57                   	push   %edi
  4d:	4e                   	dec    %esi
  4e:	00 75 6e             	add    %dh,0x6e(%ebp)
  51:	73 69                	jae    bc <.debug_str+0xbc>
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
           (CONSOLE_HEIGHT - 1) * CONSOLE_WIDTH * CONSOLE_CHAR_SIZE);

    for (i = 0; i < CONSOLE_WIDTH; ++i)
  53:	67 6e                	outsb  %ds:(%si),(%dx)
  55:	65 64 20 63 68       	gs and %ah,%fs:%gs:0x68(%ebx)
  5a:	61                   	popa   
  5b:	72 00                	jb     5d <.debug_str+0x5d>
    {
        vga_mem[CONSOLE_WIDTH * (CONSOLE_HEIGHT - 1) + i] = blank;
    }
}
  5d:	61                   	popa   
  5e:	74 74                	je     d4 <.debug_str+0xd4>

void set_cursor(int x, int y)
{
  60:	72 00                	jb     62 <.debug_str+0x62>
  62:	73 68                	jae    cc <.debug_str+0xcc>
  64:	6f                   	outsl  %ds:(%esi),(%dx)
    u16int position;
    csr_x = x;
  65:	72 74                	jb     db <.debug_str+0xdb>
  67:	20 75 6e             	and    %dh,0x6e(%ebp)
  6a:	73 69                	jae    d5 <.debug_str+0xd5>
  6c:	67 6e                	outsb  %ds:(%si),(%dx)
    csr_y = y;
  6e:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
  73:	74 00                	je     75 <.debug_str+0x75>

    position = csr_y * CONSOLE_WIDTH + csr_x;
  75:	4c                   	dec    %esp
  76:	49                   	dec    %ecx
  77:	47                   	inc    %edi
  78:	48                   	dec    %eax
  79:	54                   	push   %esp
  7a:	5f                   	pop    %edi
  7b:	52                   	push   %edx
  7c:	45                   	inc    %ebp
  7d:	44                   	inc    %esp
  7e:	00 4c 49 47          	add    %cl,0x47(%ecx,%ecx,2)
  82:	48                   	dec    %eax
  83:	54                   	push   %esp
  84:	5f                   	pop    %edi
  85:	4d                   	dec    %ebp
  86:	41                   	inc    %ecx
  87:	47                   	inc    %edi
  88:	45                   	inc    %ebp
  89:	4e                   	dec    %esi
  8a:	54                   	push   %esp
  8b:	41                   	inc    %ecx
  8c:	00 2f                	add    %ch,(%edi)
  8e:	68 6f 6d 65 2f       	push   $0x2f656d6f

    outb(0x0f, 0x3d4);
  93:	62 6c 65 73          	bound  %ebp,0x73(%ebp,%eiz,2)
  97:	73 65                	jae    fe <.debug_str+0xfe>
  99:	64                   	fs
  9a:	2f                   	das    
  9b:	50                   	push   %eax
  9c:	72 6f                	jb     10d <.debug_str+0x10d>
  9e:	67 72 61             	addr16 jb 102 <.debug_str+0x102>
  a1:	6d                   	insl   (%dx),%es:(%edi)
  a2:	6f                   	outsl  %ds:(%esi),(%dx)
  a3:	77 61                	ja     106 <.debug_str+0x106>
  a5:	6e                   	outsb  %ds:(%esi),(%dx)
  a6:	69 65 2f 62 6c 65 73 	imul   $0x73656c62,0x2f(%ebp),%esp
    outb((u8int)(position & 0xff), 0x3d5);
  ad:	73 4f                	jae    fe <.debug_str+0xfe>
  af:	53                   	push   %ebx
  b0:	2f                   	das    
  b1:	65                   	gs
  b2:	78 2f                	js     e3 <.debug_str+0xe3>
  b4:	73 72                	jae    128 <.debug_str+0x128>
  b6:	63 2f                	arpl   %bp,(%edi)
  b8:	63 6f 6e             	arpl   %bp,0x6e(%edi)
  bb:	73 6f                	jae    12c <.debug_str+0x12c>
  bd:	6c                   	insb   (%dx),%es:(%edi)
    outb(0x0e, 0x3d4);
  be:	65                   	gs
  bf:	2f                   	das    
  c0:	63 6f 6e             	arpl   %bp,0x6e(%edi)
  c3:	73 6f                	jae    134 <.debug_str+0x134>
  c5:	6c                   	insb   (%dx),%es:(%edi)
  c6:	65 2e 63 00          	gs arpl %ax,%cs:%gs:(%eax)
  ca:	43                   	inc    %ebx
  cb:	59                   	pop    %ecx
  cc:	41                   	inc    %ecx
  cd:	4e                   	dec    %esi
  ce:	00 4d 41             	add    %cl,0x41(%ebp)
  d1:	47                   	inc    %edi
    outb((u8int)((position >> 8) & 0xff), 0x3d5);
  d2:	45                   	inc    %ebp
  d3:	4e                   	dec    %esi
  d4:	54                   	push   %esp
  d5:	41                   	inc    %ecx
  d6:	00 63 6f             	add    %ah,0x6f(%ebx)
  d9:	6e                   	outsb  %ds:(%esi),(%dx)
  da:	73 6f                	jae    14b <.debug_str+0x14b>
  dc:	6c                   	insb   (%dx),%es:(%edi)
  dd:	65                   	gs
  de:	5f                   	pop    %edi
  df:	69 6e 69 74 00 73 63 	imul   $0x63730074,0x69(%esi),%ebp
  e6:	72 6f                	jb     157 <.debug_str+0x157>
  e8:	6c                   	insb   (%dx),%es:(%edi)
  e9:	6c                   	insb   (%dx),%es:(%edi)
  ea:	5f                   	pop    %edi
  eb:	64 6f                	outsl  %fs:(%esi),(%dx)
}
  ed:	77 6e                	ja     15d <.debug_str+0x15d>

void get_cursor(int *x, int *y)
{
  ef:	00 73 65             	add    %dh,0x65(%ebx)
    *x = csr_x;
  f2:	74 5f                	je     153 <.debug_str+0x153>
  f4:	63 75 72             	arpl   %si,0x72(%ebp)
  f7:	73 6f                	jae    168 <.debug_str+0x168>
  f9:	72 00                	jb     fb <.debug_str+0xfb>
  fb:	75 38                	jne    135 <.debug_str+0x135>
    *y = csr_y;
  fd:	69 6e 74 00 43 4f 4e 	imul   $0x4e4f4300,0x74(%esi),%ebp
 104:	53                   	push   %ebx
 105:	4f                   	dec    %edi
 106:	4c                   	dec    %esp
 107:	45                   	inc    %ebp
}
 108:	5f                   	pop    %edi
 109:	43                   	inc    %ebx

void console_init()
{
 10a:	4f                   	dec    %edi
 10b:	4c                   	dec    %esp
 10c:	4f                   	dec    %edi
 10d:	52                   	push   %edx
 10e:	00 57 48             	add    %dl,0x48(%edi)
    clear_screen();
 111:	49                   	dec    %ecx
 112:	54                   	push   %esp
 113:	45                   	inc    %ebp
 114:	00 75 6e             	add    %dh,0x6e(%ebp)

    set_cursor(0, 0);
 117:	73 69                	jae    182 <.debug_str+0x182>
 119:	67 6e                	outsb  %ds:(%si),(%dx)
 11b:	65 64 20 69 6e       	gs and %ch,%fs:%gs:0x6e(%ecx)
 120:	74 00                	je     122 <.debug_str+0x122>
 122:	42                   	inc    %edx
 123:	4c                   	dec    %esp
 124:	41                   	inc    %ecx
 125:	43                   	inc    %ebx
 126:	4b                   	dec    %ebx
 127:	00 63 68             	add    %ah,0x68(%ebx)
}
 12a:	61                   	popa   

void clear_screen()
{
 12b:	72 00                	jb     12d <.debug_str+0x12d>
 12d:	4c                   	dec    %esp
 12e:	49                   	dec    %ecx
 12f:	47                   	inc    %edi
 130:	48                   	dec    %eax
    u16int *vga_mem = (u16int *)VRAM_START;
 131:	54                   	push   %esp
 132:	5f                   	pop    %edi
 133:	42                   	inc    %edx
 134:	4c                   	dec    %esp
 135:	55                   	push   %ebp
 136:	45                   	inc    %ebp
 137:	00 4c 49 47          	add    %cl,0x47(%ecx,%ecx,2)
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);
 13b:	48                   	dec    %eax
 13c:	54                   	push   %esp
 13d:	5f                   	pop    %edi

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
 13e:	47                   	inc    %edi
 13f:	52                   	push   %edx
 140:	45                   	inc    %ebp
 141:	45                   	inc    %ebp
 142:	4e                   	dec    %esi
 143:	00 63 73             	add    %ah,0x73(%ebx)
    for (; count > 0; count--)
 146:	72 5f                	jb     1a7 <print_c+0x46>
        *vga_mem++ = blankchar;
 148:	79 00                	jns    14a <.debug_str+0x14a>
 14a:	47                   	inc    %edi
 14b:	4e                   	dec    %esi
 14c:	55                   	push   %ebp
 14d:	20 43 20             	and    %al,0x20(%ebx)
 150:	34 2e                	xor    $0x2e,%al
 152:	37                   	aaa    
 153:	2e 33 00             	xor    %cs:(%eax),%eax
{
    u16int *vga_mem = (u16int *)VRAM_START;
    u16int blankchar = 0x20 | (((0 << 4 ) | (15 & 0xff)) << 8);

    int count = CONSOLE_WIDTH * CONSOLE_HEIGHT;
    for (; count > 0; count--)
 156:	63 6f 75             	arpl   %bp,0x75(%edi)
 159:	6e                   	outsb  %ds:(%esi),(%dx)
 15a:	74 00                	je     15c <.debug_str+0x15c>
 15c:	76 67                	jbe    1c5 <print_c+0x64>
 15e:	61                   	popa   
        *vga_mem++ = blankchar;
}
 15f:	5f                   	pop    %edi
 160:	6d                   	insl   (%dx),%es:(%edi)

void print_c(char c, CONSOLE_COLOR fg, CONSOLE_COLOR bg)
{
 161:	65                   	gs
 162:	6d                   	insl   (%dx),%es:(%edi)
 163:	00 70 6f             	add    %dh,0x6f(%eax)
 166:	73 69                	jae    1d1 <print_c+0x70>
 168:	74 69                	je     1d3 <print_c+0x72>
 16a:	6f                   	outsl  %ds:(%esi),(%dx)
 16b:	6e                   	outsb  %ds:(%esi),(%dx)
 16c:	00 62 6c             	add    %ah,0x6c(%edx)
    u8int *dest = (u8int *)(VRAM_START + csr_y * VRAM_LINE + csr_x * CONSOLE_CHAR_SIZE);
 16f:	61                   	popa   
 170:	6e                   	outsb  %ds:(%esi),(%dx)
 171:	6b 63 68 61          	imul   $0x61,0x68(%ebx),%esp
 175:	72 00                	jb     177 <.debug_str+0x177>
 177:	4c                   	dec    %esp
 178:	49                   	dec    %ecx
 179:	47                   	inc    %edi
 17a:	48                   	dec    %eax
 17b:	54                   	push   %esp
 17c:	5f                   	pop    %edi
 17d:	43                   	inc    %ebx
 17e:	59                   	pop    %ecx
 17f:	41                   	inc    %ecx
 180:	4e                   	dec    %esi
 181:	00 75 31             	add    %dh,0x31(%ebp)
 184:	36 69 6e 74 00 59 45 	imul   $0x4c455900,%ss:0x74(%esi),%ebp
 18b:	4c 
 18c:	4c                   	dec    %esp
 18d:	4f                   	dec    %edi
 18e:	57                   	push   %edi
    u8int attr = (u8int)(bg << 4 | fg );
 18f:	00 47 52             	add    %al,0x52(%edi)
 192:	41                   	inc    %ecx
 193:	59                   	pop    %ecx
	...

Disassembly of section .comment:

00000000 <.comment>:
#include <console/console.h>

static int csr_x, csr_y;

static void scroll_down()
{
   0:	00 47 43             	add    %al,0x43(%edi)
   3:	43                   	inc    %ebx
   4:	3a 20                	cmp    (%eax),%ah
    int i;
    u16int *vga_mem = (u16int *)VRAM_START;
   6:	28 44 65 62          	sub    %al,0x62(%ebp,%eiz,2)
   a:	69 61 6e 20 34 2e 37 	imul   $0x372e3420,0x6e(%ecx),%esp
    u16int blank = 0x20 | (((0 << 4) | (15 & 0xff)) << 8);
  11:	2e 33 2d 34 29 20 34 	xor    %cs:0x34202934,%ebp

    memcpy(vga_mem, vga_mem + CONSOLE_WIDTH,
  18:	2e                   	cs
  19:	37                   	aaa    
  1a:	2e 33 00             	xor    %cs:(%eax),%eax

Disassembly of section .eh_frame:

00000000 <.eh_frame>:
   0:	14 00                	adc    $0x0,%al
   2:	00 00                	add    %al,(%eax)
   4:	00 00                	add    %al,(%eax)
   6:	00 00                	add    %al,(%eax)
   8:	01 7a 52             	add    %edi,0x52(%edx)
   b:	00 01                	add    %al,(%ecx)
   d:	7c 08                	jl     17 <.eh_frame+0x17>
   f:	01 1b                	add    %ebx,(%ebx)
  11:	0c 04                	or     $0x4,%al
  13:	04 88                	add    $0x88,%al
  15:	01 00                	add    %eax,(%eax)
  17:	00 1c 00             	add    %bl,(%eax,%eax,1)
  1a:	00 00                	add    %al,(%eax)
  1c:	1c 00                	sbb    $0x0,%al
  1e:	00 00                	add    %al,(%eax)
  20:	00 00                	add    %al,(%eax)
			20: R_386_PC32	.text
  22:	00 00                	add    %al,(%eax)
  24:	5f                   	pop    %edi
  25:	00 00                	add    %al,(%eax)
  27:	00 00                	add    %al,(%eax)
  29:	41                   	inc    %ecx
  2a:	0e                   	push   %cs
  2b:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  31:	02 5b c5             	add    -0x3b(%ebx),%bl
  34:	0c 04                	or     $0x4,%al
  36:	04 00                	add    $0x0,%al
  38:	1c 00                	sbb    $0x0,%al
  3a:	00 00                	add    %al,(%eax)
  3c:	3c 00                	cmp    $0x0,%al
  3e:	00 00                	add    %al,(%eax)
  40:	5f                   	pop    %edi
			40: R_386_PC32	.text
  41:	00 00                	add    %al,(%eax)
  43:	00 90 00 00 00 00    	add    %dl,0x0(%eax)
  49:	41                   	inc    %ecx
  4a:	0e                   	push   %cs
  4b:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  51:	02 8c c5 0c 04 04 00 	add    0x4040c(%ebp,%eax,8),%cl
  58:	1c 00                	sbb    $0x0,%al
  5a:	00 00                	add    %al,(%eax)
  5c:	5c                   	pop    %esp
  5d:	00 00                	add    %al,(%eax)
  5f:	00 ef                	add    %ch,%bh
			60: R_386_PC32	.text
  61:	00 00                	add    %al,(%eax)
  63:	00 1b                	add    %bl,(%ebx)
  65:	00 00                	add    %al,(%eax)
  67:	00 00                	add    %al,(%eax)
  69:	41                   	inc    %ecx
  6a:	0e                   	push   %cs
  6b:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  71:	57                   	push   %edi
  72:	c5 0c 04             	lds    (%esp,%eax,1),%ecx
  75:	04 00                	add    $0x0,%al
  77:	00 1c 00             	add    %bl,(%eax,%eax,1)
  7a:	00 00                	add    %al,(%eax)
  7c:	7c 00                	jl     7e <.eh_frame+0x7e>
  7e:	00 00                	add    %al,(%eax)
  80:	0a 01                	or     (%ecx),%al
			80: R_386_PC32	.text
  82:	00 00                	add    %al,(%eax)
  84:	21 00                	and    %eax,(%eax)
  86:	00 00                	add    %al,(%eax)
  88:	00 41 0e             	add    %al,0xe(%ecx)
  8b:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  91:	5d                   	pop    %ebp
  92:	c5 0c 04             	lds    (%esp,%eax,1),%ecx
  95:	04 00                	add    $0x0,%al
  97:	00 1c 00             	add    %bl,(%eax,%eax,1)
  9a:	00 00                	add    %al,(%eax)
  9c:	9c                   	pushf  
  9d:	00 00                	add    %al,(%eax)
  9f:	00 2b                	add    %ch,(%ebx)
			a0: R_386_PC32	.text
  a1:	01 00                	add    %eax,(%eax)
  a3:	00 36                	add    %dh,(%esi)
  a5:	00 00                	add    %al,(%eax)
  a7:	00 00                	add    %al,(%eax)
  a9:	41                   	inc    %ecx
  aa:	0e                   	push   %cs
  ab:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  b1:	72 c5                	jb     78 <.eh_frame+0x78>
  b3:	0c 04                	or     $0x4,%al
  b5:	04 00                	add    $0x0,%al
  b7:	00 1c 00             	add    %bl,(%eax,%eax,1)
  ba:	00 00                	add    %al,(%eax)
  bc:	bc 00 00 00 61       	mov    $0x61000000,%esp
			c0: R_386_PC32	.text
  c1:	01 00                	add    %eax,(%eax)
  c3:	00 e8                	add    %ch,%al
  c5:	01 00                	add    %eax,(%eax)
  c7:	00 00                	add    %al,(%eax)
  c9:	41                   	inc    %ecx
  ca:	0e                   	push   %cs
  cb:	08 85 02 42 0d 05    	or     %al,0x50d4202(%ebp)
  d1:	03 e4                	add    %esp,%esp
  d3:	01 c5                	add    %eax,%ebp
  d5:	0c 04                	or     $0x4,%al
  d7:	04                   	.byte 0x4
